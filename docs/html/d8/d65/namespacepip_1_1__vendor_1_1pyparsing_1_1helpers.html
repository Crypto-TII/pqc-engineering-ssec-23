<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Let us walk on the 3-isogeny graph: efficient, fast, and simpleProject: pip._vendor.pyparsing.helpers Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Let us walk on the 3-isogeny graph: efficient, fast, and simpleProject
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('d8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers.html','../../',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">pip._vendor.pyparsing.helpers Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:OpAssoc" id="r_OpAssoc"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/db3/classpip_1_1__vendor_1_1pyparsing_1_1helpers_1_1_op_assoc.html">OpAssoc</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6a581ac881ccf695f1fce312b83148e5" id="r_a6a581ac881ccf695f1fce312b83148e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a581ac881ccf695f1fce312b83148e5">counted_array</a> (<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> expr, typing.Optional[<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] int_expr=None, *, typing.Optional[<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] intExpr=None)</td></tr>
<tr class="memitem:ada847ea890ad0539072827b2b01eb826" id="r_ada847ea890ad0539072827b2b01eb826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada847ea890ad0539072827b2b01eb826">match_previous_literal</a> (<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> expr)</td></tr>
<tr class="memitem:aea316bc5f32af937c8c4a3735c81c4b0" id="r_aea316bc5f32af937c8c4a3735c81c4b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea316bc5f32af937c8c4a3735c81c4b0">match_previous_expr</a> (<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> expr)</td></tr>
<tr class="memitem:a1223bf0100ee5dd569d6829217ca647e" id="r_a1223bf0100ee5dd569d6829217ca647e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1223bf0100ee5dd569d6829217ca647e">one_of</a> (Union[typing.Iterable[str], str] strs, bool caseless=False, bool use_regex=True, bool as_keyword=False, *, bool useRegex=True, bool asKeyword=False)</td></tr>
<tr class="memitem:a692cd74a30fd5e78039c1cb4cc490f6d" id="r_a692cd74a30fd5e78039c1cb4cc490f6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a692cd74a30fd5e78039c1cb4cc490f6d">dict_of</a> (<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> key, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> value)</td></tr>
<tr class="memitem:a393a0bb189c88de859edc6306176ccc4" id="r_a393a0bb189c88de859edc6306176ccc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a393a0bb189c88de859edc6306176ccc4">original_text_for</a> (<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> expr, bool as_string=True, *, bool asString=True)</td></tr>
<tr class="memitem:a5af53f3b8905da730a89a54b5167deab" id="r_a5af53f3b8905da730a89a54b5167deab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af53f3b8905da730a89a54b5167deab">ungroup</a> (<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> expr)</td></tr>
<tr class="memitem:a8b2dc27e553a663c0a256fb76cb4c5b6" id="r_a8b2dc27e553a663c0a256fb76cb4c5b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b2dc27e553a663c0a256fb76cb4c5b6">locatedExpr</a> (<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> expr)</td></tr>
<tr class="memitem:a781ed9a599f578cf3104839d2fbbdfd7" id="r_a781ed9a599f578cf3104839d2fbbdfd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a781ed9a599f578cf3104839d2fbbdfd7">nested_expr</a> (Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] opener=&quot;(&quot;, Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] closer=&quot;)&quot;, typing.Optional[<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] content=None, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> ignore_expr=<a class="el" href="../../da/d31/namespacepip_1_1__vendor_1_1pyparsing_1_1core.html#a9a959fed7ee6e3337cf1a15d48fc962f">quoted_string</a>(), *, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> ignoreExpr=<a class="el" href="../../da/d31/namespacepip_1_1__vendor_1_1pyparsing_1_1core.html#a9a959fed7ee6e3337cf1a15d48fc962f">quoted_string</a>())</td></tr>
<tr class="memitem:ada515ee172e0f92aaa93f7be47f0f93e" id="r_ada515ee172e0f92aaa93f7be47f0f93e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada515ee172e0f92aaa93f7be47f0f93e">_makeTags</a> (tagStr, xml, suppress_LT=<a class="el" href="../../d8/d99/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_suppress.html">Suppress</a>(&quot;&lt;&quot;), suppress_GT=<a class="el" href="../../d8/d99/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_suppress.html">Suppress</a>(&quot;&gt;&quot;))</td></tr>
<tr class="memitem:a780336396004a526fa5caedd9b204a98" id="r_a780336396004a526fa5caedd9b204a98"><td class="memItemLeft" align="right" valign="top">Tuple[<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a780336396004a526fa5caedd9b204a98">make_html_tags</a> (Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] tag_str)</td></tr>
<tr class="memitem:a128b9c58053ca5b54aac0e1ee646570a" id="r_a128b9c58053ca5b54aac0e1ee646570a"><td class="memItemLeft" align="right" valign="top">Tuple[<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a128b9c58053ca5b54aac0e1ee646570a">make_xml_tags</a> (Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] tag_str)</td></tr>
<tr class="memitem:a57d892d89e8867238db64e7b794cee6e" id="r_a57d892d89e8867238db64e7b794cee6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57d892d89e8867238db64e7b794cee6e">replace_html_entity</a> (s, l, t)</td></tr>
<tr class="memitem:a218fd6c8f356e0b02c13805b7fc1cf99" id="r_a218fd6c8f356e0b02c13805b7fc1cf99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a218fd6c8f356e0b02c13805b7fc1cf99">infix_notation</a> (<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> base_expr, List[<a class="el" href="#a732829e9bcf9affdfe67f35af42c0915">InfixNotationOperatorSpec</a>] op_list, Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] lpar=<a class="el" href="../../d8/d99/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_suppress.html">Suppress</a>(&quot;(&quot;), Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] rpar=<a class="el" href="../../d8/d99/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_suppress.html">Suppress</a>(&quot;)&quot;))</td></tr>
<tr class="memitem:ad41b53e5d3582308e6e8de5a5827d722" id="r_ad41b53e5d3582308e6e8de5a5827d722"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad41b53e5d3582308e6e8de5a5827d722">indentedBlock</a> (blockStatementExpr, indentStack, indent=True, backup_stacks=[])</td></tr>
<tr class="memitem:aa80cb27d1e416bf9aaefd82ce90ae081" id="r_aa80cb27d1e416bf9aaefd82ce90ae081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa80cb27d1e416bf9aaefd82ce90ae081">delimited_list</a> (Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] expr, Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] delim=&quot;,&quot;, bool combine=False, typing.Optional[int] min=None, typing.Optional[int] max=None, *, bool allow_trailing_delim=False)</td></tr>
<tr class="memitem:acfd1f603ce2b1f3c4bcc585ed191b662" id="r_acfd1f603ce2b1f3c4bcc585ed191b662"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfd1f603ce2b1f3c4bcc585ed191b662">delimitedList</a> ()</td></tr>
<tr class="memitem:a2c0c3ed149c977c4f0a7e738503ddca0" id="r_a2c0c3ed149c977c4f0a7e738503ddca0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c0c3ed149c977c4f0a7e738503ddca0">delimited_list</a> ()</td></tr>
<tr class="memitem:adc0342d0a3af7962b5637476a8fb2db5" id="r_adc0342d0a3af7962b5637476a8fb2db5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc0342d0a3af7962b5637476a8fb2db5">countedArray</a> ()</td></tr>
<tr class="memitem:a943b281daeb4781d29c9eb84035c28f1" id="r_a943b281daeb4781d29c9eb84035c28f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a943b281daeb4781d29c9eb84035c28f1">matchPreviousLiteral</a> ()</td></tr>
<tr class="memitem:a72893e5434dcc18e791df70fe8f9a4e2" id="r_a72893e5434dcc18e791df70fe8f9a4e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72893e5434dcc18e791df70fe8f9a4e2">matchPreviousExpr</a> ()</td></tr>
<tr class="memitem:a364c6ad71d25ff9e9d5b4cca26b7c064" id="r_a364c6ad71d25ff9e9d5b4cca26b7c064"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a364c6ad71d25ff9e9d5b4cca26b7c064">oneOf</a> ()</td></tr>
<tr class="memitem:aabc12ac64cdc58bd79cd801f19b1a1b2" id="r_aabc12ac64cdc58bd79cd801f19b1a1b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabc12ac64cdc58bd79cd801f19b1a1b2">dictOf</a> ()</td></tr>
<tr class="memitem:a1a77d06d3576a870e167580e90b7cc21" id="r_a1a77d06d3576a870e167580e90b7cc21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a77d06d3576a870e167580e90b7cc21">originalTextFor</a> ()</td></tr>
<tr class="memitem:ac124a4d7cc2c1bced7cb243fcd497bba" id="r_ac124a4d7cc2c1bced7cb243fcd497bba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac124a4d7cc2c1bced7cb243fcd497bba">nestedExpr</a> ()</td></tr>
<tr class="memitem:a932a8ac714a4d119ef2eefd4a96e64ab" id="r_a932a8ac714a4d119ef2eefd4a96e64ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a932a8ac714a4d119ef2eefd4a96e64ab">makeHTMLTags</a> ()</td></tr>
<tr class="memitem:a93a25b14d1f9abbe6418cb2035652abf" id="r_a93a25b14d1f9abbe6418cb2035652abf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93a25b14d1f9abbe6418cb2035652abf">makeXMLTags</a> ()</td></tr>
<tr class="memitem:a8d650f775915b22fbf96f14121382d41" id="r_a8d650f775915b22fbf96f14121382d41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d650f775915b22fbf96f14121382d41">replaceHTMLEntity</a> ()</td></tr>
<tr class="memitem:afa06862d0f9515a0100e15a14738b0c0" id="r_afa06862d0f9515a0100e15a14738b0c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa06862d0f9515a0100e15a14738b0c0">infixNotation</a> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2c796b6b07970245107bcd7e2c804eff" id="r_a2c796b6b07970245107bcd7e2c804eff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c796b6b07970245107bcd7e2c804eff">any_open_tag</a></td></tr>
<tr class="memitem:ad9bb74e07c8d28a27d406e8d6b854e38" id="r_ad9bb74e07c8d28a27d406e8d6b854e38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9bb74e07c8d28a27d406e8d6b854e38">any_close_tag</a></td></tr>
<tr class="memitem:a047e5e223aae7489e33f5b80f41ec116" id="r_a047e5e223aae7489e33f5b80f41ec116"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a047e5e223aae7489e33f5b80f41ec116">_htmlEntityMap</a> = {k.rstrip(&quot;;&quot;): v <a class="el" href="../../d2/d00/prime__search_8m.html#ace560ef83cc4488bf05ef19ddc3f6f34">for</a> k, v in html.entities.html5.items()}</td></tr>
<tr class="memitem:a092f994e0bc691fed7ec122ee421a5bf" id="r_a092f994e0bc691fed7ec122ee421a5bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a092f994e0bc691fed7ec122ee421a5bf">common_html_entity</a></td></tr>
<tr class="memitem:aee3d4b5ec7657944e5809e120e0349ba" id="r_aee3d4b5ec7657944e5809e120e0349ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee3d4b5ec7657944e5809e120e0349ba">InfixNotationOperatorArgType</a></td></tr>
<tr class="memitem:a732829e9bcf9affdfe67f35af42c0915" id="r_a732829e9bcf9affdfe67f35af42c0915"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a732829e9bcf9affdfe67f35af42c0915">InfixNotationOperatorSpec</a></td></tr>
<tr class="memitem:a94f77d2e92e4932420592c1d562734d0" id="r_a94f77d2e92e4932420592c1d562734d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94f77d2e92e4932420592c1d562734d0">c_style_comment</a></td></tr>
<tr class="memitem:aa51b7b384ad578c0391f372c76c3b1fe" id="r_aa51b7b384ad578c0391f372c76c3b1fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa51b7b384ad578c0391f372c76c3b1fe">html_comment</a> = <a class="el" href="../../d2/d3c/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_regex.html">Regex</a>(r&quot;&lt;!--[\s\S]*?--&gt;&quot;).set_name(&quot;HTML comment&quot;)</td></tr>
<tr class="memitem:a3fa0a48a3ccef1245bd6748bc8a34fc6" id="r_a3fa0a48a3ccef1245bd6748bc8a34fc6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fa0a48a3ccef1245bd6748bc8a34fc6">rest_of_line</a> = <a class="el" href="../../d2/d3c/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_regex.html">Regex</a>(r&quot;.*&quot;).leave_whitespace().set_name(&quot;rest of line&quot;)</td></tr>
<tr class="memitem:a222d83ba5a187d473bfb260fe8a76141" id="r_a222d83ba5a187d473bfb260fe8a76141"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a222d83ba5a187d473bfb260fe8a76141">dbl_slash_comment</a> = <a class="el" href="../../d2/d3c/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_regex.html">Regex</a>(r&quot;//(?:\\\n|[^\n])*&quot;).set_name(&quot;// comment&quot;)</td></tr>
<tr class="memitem:aba5207462b24d6364ba9ef3472c12247" id="r_aba5207462b24d6364ba9ef3472c12247"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba5207462b24d6364ba9ef3472c12247">cpp_style_comment</a></td></tr>
<tr class="memitem:aa6be426385d10903cb8f653a282d5a07" id="r_aa6be426385d10903cb8f653a282d5a07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6be426385d10903cb8f653a282d5a07">java_style_comment</a> = <a class="el" href="#aba5207462b24d6364ba9ef3472c12247">cpp_style_comment</a></td></tr>
<tr class="memitem:a1bd3a91984dd47292168fbdfb7302dc0" id="r_a1bd3a91984dd47292168fbdfb7302dc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bd3a91984dd47292168fbdfb7302dc0">python_style_comment</a> = <a class="el" href="../../d2/d3c/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_regex.html">Regex</a>(r&quot;#.*&quot;).set_name(&quot;Python style comment&quot;)</td></tr>
<tr class="memitem:ae3ac06a44de11c72db8d322c8499b63c" id="r_ae3ac06a44de11c72db8d322c8499b63c"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3ac06a44de11c72db8d322c8499b63c">_builtin_exprs</a></td></tr>
<tr class="memitem:acfe54ba9c774a0b721484b122675ae49" id="r_acfe54ba9c774a0b721484b122675ae49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfe54ba9c774a0b721484b122675ae49">opAssoc</a> = <a class="el" href="../../d9/db3/classpip_1_1__vendor_1_1pyparsing_1_1helpers_1_1_op_assoc.html">OpAssoc</a></td></tr>
<tr class="memitem:a89443f23bd7f10a1dd3ec7a30fbc1f90" id="r_a89443f23bd7f10a1dd3ec7a30fbc1f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89443f23bd7f10a1dd3ec7a30fbc1f90">anyOpenTag</a> = <a class="el" href="#a2c796b6b07970245107bcd7e2c804eff">any_open_tag</a></td></tr>
<tr class="memitem:a91098f82290f3d945c5e61fcc3ef0643" id="r_a91098f82290f3d945c5e61fcc3ef0643"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91098f82290f3d945c5e61fcc3ef0643">anyCloseTag</a> = <a class="el" href="#ad9bb74e07c8d28a27d406e8d6b854e38">any_close_tag</a></td></tr>
<tr class="memitem:a7f80f97b0a7e5a08496b213c71d76301" id="r_a7f80f97b0a7e5a08496b213c71d76301"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f80f97b0a7e5a08496b213c71d76301">commonHTMLEntity</a> = <a class="el" href="#a092f994e0bc691fed7ec122ee421a5bf">common_html_entity</a></td></tr>
<tr class="memitem:a895af36e449c2367f530adbdc5d935e2" id="r_a895af36e449c2367f530adbdc5d935e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a895af36e449c2367f530adbdc5d935e2">cStyleComment</a> = <a class="el" href="#a94f77d2e92e4932420592c1d562734d0">c_style_comment</a></td></tr>
<tr class="memitem:aabee8ef3c357ba56650e39fb3ab14bbe" id="r_aabee8ef3c357ba56650e39fb3ab14bbe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabee8ef3c357ba56650e39fb3ab14bbe">htmlComment</a> = <a class="el" href="#aa51b7b384ad578c0391f372c76c3b1fe">html_comment</a></td></tr>
<tr class="memitem:ac9d295aa38fd39ae00f04140cc6531bc" id="r_ac9d295aa38fd39ae00f04140cc6531bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9d295aa38fd39ae00f04140cc6531bc">restOfLine</a> = <a class="el" href="#a3fa0a48a3ccef1245bd6748bc8a34fc6">rest_of_line</a></td></tr>
<tr class="memitem:a4b0fb4b75d2a7eac67175e156af9f9fd" id="r_a4b0fb4b75d2a7eac67175e156af9f9fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b0fb4b75d2a7eac67175e156af9f9fd">dblSlashComment</a> = <a class="el" href="#a222d83ba5a187d473bfb260fe8a76141">dbl_slash_comment</a></td></tr>
<tr class="memitem:a8e7682f0a25965d2916d2cceadc749e9" id="r_a8e7682f0a25965d2916d2cceadc749e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e7682f0a25965d2916d2cceadc749e9">cppStyleComment</a> = <a class="el" href="#aba5207462b24d6364ba9ef3472c12247">cpp_style_comment</a></td></tr>
<tr class="memitem:a95a4a4592db29ee9a5cb46c07d86e715" id="r_a95a4a4592db29ee9a5cb46c07d86e715"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95a4a4592db29ee9a5cb46c07d86e715">javaStyleComment</a> = <a class="el" href="#aa6be426385d10903cb8f653a282d5a07">java_style_comment</a></td></tr>
<tr class="memitem:a43485b104d2aeb59f207edd35054d3dd" id="r_a43485b104d2aeb59f207edd35054d3dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43485b104d2aeb59f207edd35054d3dd">pythonStyleComment</a> = <a class="el" href="#a1bd3a91984dd47292168fbdfb7302dc0">python_style_comment</a></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ada515ee172e0f92aaa93f7be47f0f93e" name="ada515ee172e0f92aaa93f7be47f0f93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada515ee172e0f92aaa93f7be47f0f93e">&#9670;&#160;</a></span>_makeTags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_makeTags </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>tagStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>xml</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>suppress_LT</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d99/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_suppress.html">Suppress</a>(&quot;&lt;&quot;)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>suppress_GT</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d99/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_suppress.html">Suppress</a>(&quot;&gt;&quot;)</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Internal helper to construct opening and closing tag expressions, given a tag name</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00541">541</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  541</span><span class="keyword">def </span>_makeTags(tagStr, xml, suppress_LT=Suppress(<span class="stringliteral">&quot;&lt;&quot;</span>), suppress_GT=Suppress(<span class="stringliteral">&quot;&gt;&quot;</span>)):</div>
<div class="line"><span class="lineno">  542</span>    <span class="stringliteral">&quot;&quot;&quot;Internal helper to construct opening and closing tag expressions, given a tag name&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  543</span>    <span class="keywordflow">if</span> isinstance(tagStr, str_type):</div>
<div class="line"><span class="lineno">  544</span>        resname = tagStr</div>
<div class="line"><span class="lineno">  545</span>        tagStr = Keyword(tagStr, caseless=<span class="keywordflow">not</span> xml)</div>
<div class="line"><span class="lineno">  546</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  547</span>        resname = tagStr.name</div>
<div class="line"><span class="lineno">  548</span> </div>
<div class="line"><span class="lineno">  549</span>    tagAttrName = Word(alphas, alphanums + <span class="stringliteral">&quot;_-:&quot;</span>)</div>
<div class="line"><span class="lineno">  550</span>    <span class="keywordflow">if</span> xml:</div>
<div class="line"><span class="lineno">  551</span>        tagAttrValue = dbl_quoted_string.copy().set_parse_action(remove_quotes)</div>
<div class="line"><span class="lineno">  552</span>        openTag = (</div>
<div class="line"><span class="lineno">  553</span>            suppress_LT</div>
<div class="line"><span class="lineno">  554</span>            + tagStr(<span class="stringliteral">&quot;tag&quot;</span>)</div>
<div class="line"><span class="lineno">  555</span>            + Dict(ZeroOrMore(Group(tagAttrName + Suppress(<span class="stringliteral">&quot;=&quot;</span>) + tagAttrValue)))</div>
<div class="line"><span class="lineno">  556</span>            + Opt(<span class="stringliteral">&quot;/&quot;</span>, default=[<span class="keyword">False</span>])(<span class="stringliteral">&quot;empty&quot;</span>).set_parse_action(</div>
<div class="line"><span class="lineno">  557</span>                <span class="keyword">lambda</span> s, l, t: t[0] == <span class="stringliteral">&quot;/&quot;</span></div>
<div class="line"><span class="lineno">  558</span>            )</div>
<div class="line"><span class="lineno">  559</span>            + suppress_GT</div>
<div class="line"><span class="lineno">  560</span>        )</div>
<div class="line"><span class="lineno">  561</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  562</span>        tagAttrValue = quoted_string.copy().set_parse_action(remove_quotes) | Word(</div>
<div class="line"><span class="lineno">  563</span>            printables, exclude_chars=<span class="stringliteral">&quot;&gt;&quot;</span></div>
<div class="line"><span class="lineno">  564</span>        )</div>
<div class="line"><span class="lineno">  565</span>        openTag = (</div>
<div class="line"><span class="lineno">  566</span>            suppress_LT</div>
<div class="line"><span class="lineno">  567</span>            + tagStr(<span class="stringliteral">&quot;tag&quot;</span>)</div>
<div class="line"><span class="lineno">  568</span>            + Dict(</div>
<div class="line"><span class="lineno">  569</span>                ZeroOrMore(</div>
<div class="line"><span class="lineno">  570</span>                    Group(</div>
<div class="line"><span class="lineno">  571</span>                        tagAttrName.set_parse_action(<span class="keyword">lambda</span> t: t[0].lower())</div>
<div class="line"><span class="lineno">  572</span>                        + Opt(Suppress(<span class="stringliteral">&quot;=&quot;</span>) + tagAttrValue)</div>
<div class="line"><span class="lineno">  573</span>                    )</div>
<div class="line"><span class="lineno">  574</span>                )</div>
<div class="line"><span class="lineno">  575</span>            )</div>
<div class="line"><span class="lineno">  576</span>            + Opt(<span class="stringliteral">&quot;/&quot;</span>, default=[<span class="keyword">False</span>])(<span class="stringliteral">&quot;empty&quot;</span>).set_parse_action(</div>
<div class="line"><span class="lineno">  577</span>                <span class="keyword">lambda</span> s, l, t: t[0] == <span class="stringliteral">&quot;/&quot;</span></div>
<div class="line"><span class="lineno">  578</span>            )</div>
<div class="line"><span class="lineno">  579</span>            + suppress_GT</div>
<div class="line"><span class="lineno">  580</span>        )</div>
<div class="line"><span class="lineno">  581</span>    closeTag = Combine(Literal(<span class="stringliteral">&quot;&lt;/&quot;</span>) + tagStr + <span class="stringliteral">&quot;&gt;&quot;</span>, adjacent=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  582</span> </div>
<div class="line"><span class="lineno">  583</span>    openTag.set_name(<span class="stringliteral">&quot;&lt;%s&gt;&quot;</span> % resname)</div>
<div class="line"><span class="lineno">  584</span>    <span class="comment"># add start&lt;tagname&gt; results name in parse action now that ungrouped names are not reported at two levels</span></div>
<div class="line"><span class="lineno">  585</span>    openTag.add_parse_action(</div>
<div class="line"><span class="lineno">  586</span>        <span class="keyword">lambda</span> t: t.__setitem__(</div>
<div class="line"><span class="lineno">  587</span>            <span class="stringliteral">&quot;start&quot;</span> + <span class="stringliteral">&quot;&quot;</span>.join(resname.replace(<span class="stringliteral">&quot;:&quot;</span>, <span class="stringliteral">&quot; &quot;</span>).title().split()), t.copy()</div>
<div class="line"><span class="lineno">  588</span>        )</div>
<div class="line"><span class="lineno">  589</span>    )</div>
<div class="line"><span class="lineno">  590</span>    closeTag = closeTag(</div>
<div class="line"><span class="lineno">  591</span>        <span class="stringliteral">&quot;end&quot;</span> + <span class="stringliteral">&quot;&quot;</span>.join(resname.replace(<span class="stringliteral">&quot;:&quot;</span>, <span class="stringliteral">&quot; &quot;</span>).title().split())</div>
<div class="line"><span class="lineno">  592</span>    ).set_name(<span class="stringliteral">&quot;&lt;/%s&gt;&quot;</span> % resname)</div>
<div class="line"><span class="lineno">  593</span>    openTag.tag = resname</div>
<div class="line"><span class="lineno">  594</span>    closeTag.tag = resname</div>
<div class="line"><span class="lineno">  595</span>    openTag.tag_body = SkipTo(closeTag())</div>
<div class="line"><span class="lineno">  596</span>    <span class="keywordflow">return</span> openTag, closeTag</div>
<div class="line"><span class="lineno">  597</span> </div>
<div class="line"><span class="lineno">  598</span> </div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="../../d2/deb/helpers_8py_source.html#l00601">make_html_tags()</a>, and <a class="el" href="../../d2/deb/helpers_8py_source.html#l00628">make_xml_tags()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_ada515ee172e0f92aaa93f7be47f0f93e_icgraph.png" border="0" usemap="#ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_ada515ee172e0f92aaa93f7be47f0f93e_icgraph" loading="lazy" alt=""/></div>
<map name="ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_ada515ee172e0f92aaa93f7be47f0f93e_icgraph" id="ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_ada515ee172e0f92aaa93f7be47f0f93e_icgraph">
<area shape="rect" title=" " alt="" coords="171,31,259,57"/>
<area shape="rect" href="../../d8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers.html#a780336396004a526fa5caedd9b204a98" title=" " alt="" coords="5,5,123,32"/>
<area shape="poly" title=" " alt="" coords="155,37,123,31,124,26,156,31"/>
<area shape="rect" href="../../d8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers.html#a128b9c58053ca5b54aac0e1ee646570a" title=" " alt="" coords="7,56,121,83"/>
<area shape="poly" title=" " alt="" coords="156,57,122,62,121,57,155,51"/>
</map>
</div>

</div>
</div>
<a id="a6a581ac881ccf695f1fce312b83148e5" name="a6a581ac881ccf695f1fce312b83148e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a581ac881ccf695f1fce312b83148e5">&#9670;&#160;</a></span>counted_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> counted_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Optional[<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] </td>          <td class="paramname"><span class="paramname"><em>int_expr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Optional[<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] </td>          <td class="paramname"><span class="paramname"><em>intExpr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper to define a counted list of expressions.

This helper defines a pattern of the form::

    integer expr expr expr...

where the leading integer tells how many expr expressions follow.
The matched tokens returns the array of expr tokens as a list - the
leading count token is suppressed.

If ``int_expr`` is specified, it should be a pyparsing expression
that produces an integer value.

Example::

    counted_array(Word(alphas)).parse_string('2 ab cd ef')  # -&gt; ['ab', 'cd']

    # in this parser, the leading integer value is given in binary,
    # '10' indicating that 2 values are in the array
    binary_constant = Word('01').set_parse_action(lambda t: int(t[0], 2))
    counted_array(Word(alphas), int_expr=binary_constant).parse_string('10 ab cd ef')  # -&gt; ['ab', 'cd']

    # if other fields must be parsed after the count but before the
    # list items, give the fields results names and they will
    # be preserved in the returned ParseResults:
    count_with_metadata = integer + Word(alphas)("type")
    typed_array = counted_array(Word(alphanums), int_expr=count_with_metadata)("items")
    result = typed_array.parse_string("3 bool True True False")
    print(result.dump())

    # prints
    # ['True', 'True', 'False']
    # - items: ['True', 'True', 'False']
    # - type: 'bool'
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00020">20</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   25</span>) -&gt; ParserElement:</div>
<div class="line"><span class="lineno">   26</span>    <span class="stringliteral">&quot;&quot;&quot;Helper to define a counted list of expressions.</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">    This helper defines a pattern of the form::</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">        integer expr expr expr...</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">    where the leading integer tells how many expr expressions follow.</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">    The matched tokens returns the array of expr tokens as a list - the</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">    leading count token is suppressed.</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    If ``int_expr`` is specified, it should be a pyparsing expression</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">    that produces an integer value.</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">    Example::</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">        counted_array(Word(alphas)).parse_string(&#39;2 ab cd ef&#39;)  # -&gt; [&#39;ab&#39;, &#39;cd&#39;]</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">        # in this parser, the leading integer value is given in binary,</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">        # &#39;10&#39; indicating that 2 values are in the array</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">        binary_constant = Word(&#39;01&#39;).set_parse_action(lambda t: int(t[0], 2))</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">        counted_array(Word(alphas), int_expr=binary_constant).parse_string(&#39;10 ab cd ef&#39;)  # -&gt; [&#39;ab&#39;, &#39;cd&#39;]</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">        # if other fields must be parsed after the count but before the</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">        # list items, give the fields results names and they will</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">        # be preserved in the returned ParseResults:</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">        count_with_metadata = integer + Word(alphas)(&quot;type&quot;)</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">        typed_array = counted_array(Word(alphanums), int_expr=count_with_metadata)(&quot;items&quot;)</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">        result = typed_array.parse_string(&quot;3 bool True True False&quot;)</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">        print(result.dump())</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">        # prints</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">        # [&#39;True&#39;, &#39;True&#39;, &#39;False&#39;]</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">        # - items: [&#39;True&#39;, &#39;True&#39;, &#39;False&#39;]</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">        # - type: &#39;bool&#39;</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   61</span>    intExpr = intExpr <span class="keywordflow">or</span> int_expr</div>
<div class="line"><span class="lineno">   62</span>    array_expr = Forward()</div>
<div class="line"><span class="lineno">   63</span> </div>
<div class="line"><span class="lineno">   64</span>    <span class="keyword">def </span>count_field_parse_action(s, l, t):</div>
<div class="line"><span class="lineno">   65</span>        nonlocal array_expr</div>
<div class="line"><span class="lineno">   66</span>        n = t[0]</div>
<div class="line"><span class="lineno">   67</span>        array_expr &lt;&lt;= (expr * n) <span class="keywordflow">if</span> n <span class="keywordflow">else</span> Empty()</div>
<div class="line"><span class="lineno">   68</span>        <span class="comment"># clear list contents, but keep any named results</span></div>
<div class="line"><span class="lineno">   69</span>        del t[:]</div>
<div class="line"><span class="lineno">   70</span> </div>
<div class="line"><span class="lineno">   71</span>    <span class="keywordflow">if</span> intExpr <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   72</span>        intExpr = Word(nums).set_parse_action(<span class="keyword">lambda</span> t: int(t[0]))</div>
<div class="line"><span class="lineno">   73</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   74</span>        intExpr = intExpr.copy()</div>
<div class="line"><span class="lineno">   75</span>    intExpr.set_name(<span class="stringliteral">&quot;arrayLen&quot;</span>)</div>
<div class="line"><span class="lineno">   76</span>    intExpr.add_parse_action(count_field_parse_action, call_during_try=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">   77</span>    <span class="keywordflow">return</span> (intExpr + array_expr).set_name(<span class="stringliteral">&quot;(len) &quot;</span> + str(expr) + <span class="stringliteral">&quot;...&quot;</span>)</div>
<div class="line"><span class="lineno">   78</span> </div>
<div class="line"><span class="lineno">   79</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adc0342d0a3af7962b5637476a8fb2db5" name="adc0342d0a3af7962b5637476a8fb2db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0342d0a3af7962b5637476a8fb2db5">&#9670;&#160;</a></span>countedArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">countedArray </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01069">1069</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1069</span><span class="keyword">def </span>countedArray(): ...</div>
<div class="line"><span class="lineno"> 1070</span> </div>
<div class="line"><span class="lineno"> 1071</span><span class="preprocessor">@replaced_by_pep8(match_previous_literal)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c0c3ed149c977c4f0a7e738503ddca0" name="a2c0c3ed149c977c4f0a7e738503ddca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0c3ed149c977c4f0a7e738503ddca0">&#9670;&#160;</a></span>delimited_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delimited_list </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01066">1066</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1066</span><span class="keyword">def </span>delimited_list(): ...</div>
<div class="line"><span class="lineno"> 1067</span> </div>
<div class="line"><span class="lineno"> 1068</span><span class="preprocessor">@replaced_by_pep8(counted_array)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa80cb27d1e416bf9aaefd82ce90ae081" name="aa80cb27d1e416bf9aaefd82ce90ae081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80cb27d1e416bf9aaefd82ce90ae081">&#9670;&#160;</a></span>delimited_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> delimited_list </td>
          <td>(</td>
          <td class="paramtype">Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>]</td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] </td>          <td class="paramname"><span class="paramname"><em>delim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;,&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>combine</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Optional[int] </td>          <td class="paramname"><span class="paramname"><em>min</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Optional[int] </td>          <td class="paramname"><span class="paramname"><em>max</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>allow_trailing_delim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">(DEPRECATED - use :class:`DelimitedList` class)</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01033">1033</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1041</span>) -&gt; ParserElement:</div>
<div class="line"><span class="lineno"> 1042</span>    <span class="stringliteral">&quot;&quot;&quot;(DEPRECATED - use :class:`DelimitedList` class)&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1043</span>    <span class="keywordflow">return</span> DelimitedList(</div>
<div class="line"><span class="lineno"> 1044</span>        expr, delim, combine, min, max, allow_trailing_delim=allow_trailing_delim</div>
<div class="line"><span class="lineno"> 1045</span>    )</div>
<div class="line"><span class="lineno"> 1046</span> </div>
<div class="line"><span class="lineno"> 1047</span> </div>
<div class="line"><span class="lineno"> 1048</span><span class="comment"># pre-PEP8 compatible names</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="comment"># fmt: off</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="acfd1f603ce2b1f3c4bcc585ed191b662" name="acfd1f603ce2b1f3c4bcc585ed191b662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd1f603ce2b1f3c4bcc585ed191b662">&#9670;&#160;</a></span>delimitedList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delimitedList </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01063">1063</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1063</span><span class="keyword">def </span>delimitedList(): ...</div>
<div class="line"><span class="lineno"> 1064</span> </div>
<div class="line"><span class="lineno"> 1065</span><span class="preprocessor">@replaced_by_pep8(DelimitedList)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a692cd74a30fd5e78039c1cb4cc490f6d" name="a692cd74a30fd5e78039c1cb4cc490f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692cd74a30fd5e78039c1cb4cc490f6d">&#9670;&#160;</a></span>dict_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> dict_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper to easily and clearly define a dictionary by specifying
the respective patterns for the key and value.  Takes care of
defining the :class:`Dict`, :class:`ZeroOrMore`, and
:class:`Group` tokens in the proper order.  The key pattern
can include delimiting markers or punctuation, as long as they are
suppressed, thereby leaving the significant key text.  The value
pattern can include named results, so that the :class:`Dict` results
can include named token fields.

Example::

    text = "shape: SQUARE posn: upper left color: light blue texture: burlap"
    attr_expr = (label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join))
    print(attr_expr[1, ...].parse_string(text).dump())

    attr_label = label
    attr_value = Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join)

    # similar to Dict, but simpler call format
    result = dict_of(attr_label, attr_value).parse_string(text)
    print(result.dump())
    print(result['shape'])
    print(result.shape)  # object attribute access works too
    print(result.as_dict())

prints::

    [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]
    - color: 'light blue'
    - posn: 'upper left'
    - shape: 'SQUARE'
    - texture: 'burlap'
    SQUARE
    SQUARE
    {'color': 'light blue', 'shape': 'SQUARE', 'posn': 'upper left', 'texture': 'burlap'}
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00275">275</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  275</span><span class="keyword">def </span>dict_of(key: ParserElement, value: ParserElement) -&gt; ParserElement:</div>
<div class="line"><span class="lineno">  276</span>    <span class="stringliteral">&quot;&quot;&quot;Helper to easily and clearly define a dictionary by specifying</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    the respective patterns for the key and value.  Takes care of</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    defining the :class:`Dict`, :class:`ZeroOrMore`, and</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    :class:`Group` tokens in the proper order.  The key pattern</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    can include delimiting markers or punctuation, as long as they are</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    suppressed, thereby leaving the significant key text.  The value</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    pattern can include named results, so that the :class:`Dict` results</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    can include named token fields.</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    Example::</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">        text = &quot;shape: SQUARE posn: upper left color: light blue texture: burlap&quot;</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">        attr_expr = (label + Suppress(&#39;:&#39;) + OneOrMore(data_word, stop_on=label).set_parse_action(&#39; &#39;.join))</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">        print(attr_expr[1, ...].parse_string(text).dump())</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        attr_label = label</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">        attr_value = Suppress(&#39;:&#39;) + OneOrMore(data_word, stop_on=label).set_parse_action(&#39; &#39;.join)</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">        # similar to Dict, but simpler call format</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">        result = dict_of(attr_label, attr_value).parse_string(text)</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">        print(result.dump())</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">        print(result[&#39;shape&#39;])</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        print(result.shape)  # object attribute access works too</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">        print(result.as_dict())</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">    prints::</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">        [[&#39;shape&#39;, &#39;SQUARE&#39;], [&#39;posn&#39;, &#39;upper left&#39;], [&#39;color&#39;, &#39;light blue&#39;], [&#39;texture&#39;, &#39;burlap&#39;]]</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">        - color: &#39;light blue&#39;</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">        - posn: &#39;upper left&#39;</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral">        - shape: &#39;SQUARE&#39;</span></div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">        - texture: &#39;burlap&#39;</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">        SQUARE</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">        SQUARE</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">        {&#39;color&#39;: &#39;light blue&#39;, &#39;shape&#39;: &#39;SQUARE&#39;, &#39;posn&#39;: &#39;upper left&#39;, &#39;texture&#39;: &#39;burlap&#39;}</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  312</span>    <span class="keywordflow">return</span> Dict(OneOrMore(Group(key + value)))</div>
<div class="line"><span class="lineno">  313</span> </div>
<div class="line"><span class="lineno">  314</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aabc12ac64cdc58bd79cd801f19b1a1b2" name="aabc12ac64cdc58bd79cd801f19b1a1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc12ac64cdc58bd79cd801f19b1a1b2">&#9670;&#160;</a></span>dictOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dictOf </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01081">1081</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1081</span><span class="keyword">def </span>dictOf(): ...</div>
<div class="line"><span class="lineno"> 1082</span> </div>
<div class="line"><span class="lineno"> 1083</span><span class="preprocessor">@replaced_by_pep8(original_text_for)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad41b53e5d3582308e6e8de5a5827d722" name="ad41b53e5d3582308e6e8de5a5827d722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41b53e5d3582308e6e8de5a5827d722">&#9670;&#160;</a></span>indentedBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">indentedBlock </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>blockStatementExpr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>indentStack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>indent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>backup_stacks</em></span><span class="paramdefsep"> = </span><span class="paramdefval">[]</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">(DEPRECATED - use :class:`IndentedBlock` class instead)
Helper method for defining space-delimited indentation blocks,
such as those used to define block statements in Python source code.

Parameters:

- ``blockStatementExpr`` - expression defining syntax of statement that
  is repeated within the indented block
- ``indentStack`` - list created by caller to manage indentation stack
  (multiple ``statementWithIndentedBlock`` expressions within a single
  grammar should share a common ``indentStack``)
- ``indent`` - boolean indicating whether block must be indented beyond
  the current level; set to ``False`` for block of left-most statements
  (default= ``True``)

A valid block must contain at least one ``blockStatement``.

(Note that indentedBlock uses internal parse actions which make it
incompatible with packrat parsing.)

Example::

    data = '''
    def A(z):
      A1
      B = 100
      G = A2
      A2
      A3
    B
    def BB(a,b,c):
      BB1
      def BBA():
        bba1
        bba2
        bba3
    C
    D
    def spam(x,y):
         def eggs(z):
             pass
    '''


    indentStack = [1]
    stmt = Forward()

    identifier = Word(alphas, alphanums)
    funcDecl = ("def" + identifier + Group("(" + Opt(delimitedList(identifier)) + ")") + ":")
    func_body = indentedBlock(stmt, indentStack)
    funcDef = Group(funcDecl + func_body)

    rvalue = Forward()
    funcCall = Group(identifier + "(" + Opt(delimitedList(rvalue)) + ")")
    rvalue &lt;&lt; (funcCall | identifier | Word(nums))
    assignment = Group(identifier + "=" + rvalue)
    stmt &lt;&lt; (funcDef | assignment | identifier)

    module_body = stmt[1, ...]

    parseTree = module_body.parseString(data)
    parseTree.pprint()

prints::

    [['def',
      'A',
      ['(', 'z', ')'],
      ':',
      [['A1'], [['B', '=', '100']], [['G', '=', 'A2']], ['A2'], ['A3']]],
     'B',
     ['def',
      'BB',
      ['(', 'a', 'b', 'c', ')'],
      ':',
      [['BB1'], [['def', 'BBA', ['(', ')'], ':', [['bba1'], ['bba2'], ['bba3']]]]]],
     'C',
     'D',
     ['def',
      'spam',
      ['(', 'x', 'y', ')'],
      ':',
      [[['def', 'eggs', ['(', 'z', ')'], ':', [['pass']]]]]]]
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00857">857</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  857</span><span class="keyword">def </span>indentedBlock(blockStatementExpr, indentStack, indent=True, backup_stacks=[]):</div>
<div class="line"><span class="lineno">  858</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    (DEPRECATED - use :class:`IndentedBlock` class instead)</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">    Helper method for defining space-delimited indentation blocks,</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    such as those used to define block statements in Python source code.</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    Parameters:</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    - ``blockStatementExpr`` - expression defining syntax of statement that</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">      is repeated within the indented block</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    - ``indentStack`` - list created by caller to manage indentation stack</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">      (multiple ``statementWithIndentedBlock`` expressions within a single</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">      grammar should share a common ``indentStack``)</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    - ``indent`` - boolean indicating whether block must be indented beyond</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">      the current level; set to ``False`` for block of left-most statements</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">      (default= ``True``)</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    A valid block must contain at least one ``blockStatement``.</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">    (Note that indentedBlock uses internal parse actions which make it</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">    incompatible with packrat parsing.)</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    Example::</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">        data = &#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">        def A(z):</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">          A1</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">          B = 100</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">          G = A2</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">          A2</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">          A3</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">        B</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">        def BB(a,b,c):</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral">          BB1</span></div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">          def BBA():</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">            bba1</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">            bba2</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">            bba3</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral">        C</span></div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">        D</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">        def spam(x,y):</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">             def eggs(z):</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">                 pass</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">        &#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">        indentStack = [1]</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">        stmt = Forward()</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">        identifier = Word(alphas, alphanums)</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">        funcDecl = (&quot;def&quot; + identifier + Group(&quot;(&quot; + Opt(delimitedList(identifier)) + &quot;)&quot;) + &quot;:&quot;)</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">        func_body = indentedBlock(stmt, indentStack)</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">        funcDef = Group(funcDecl + func_body)</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">        rvalue = Forward()</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">        funcCall = Group(identifier + &quot;(&quot; + Opt(delimitedList(rvalue)) + &quot;)&quot;)</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral">        rvalue &lt;&lt; (funcCall | identifier | Word(nums))</span></div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">        assignment = Group(identifier + &quot;=&quot; + rvalue)</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">        stmt &lt;&lt; (funcDef | assignment | identifier)</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">        module_body = stmt[1, ...]</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">        parseTree = module_body.parseString(data)</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">        parseTree.pprint()</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">    prints::</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">        [[&#39;def&#39;,</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">          &#39;A&#39;,</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">          [&#39;(&#39;, &#39;z&#39;, &#39;)&#39;],</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">          &#39;:&#39;,</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">          [[&#39;A1&#39;], [[&#39;B&#39;, &#39;=&#39;, &#39;100&#39;]], [[&#39;G&#39;, &#39;=&#39;, &#39;A2&#39;]], [&#39;A2&#39;], [&#39;A3&#39;]]],</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">         &#39;B&#39;,</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">         [&#39;def&#39;,</span></div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">          &#39;BB&#39;,</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">          [&#39;(&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;)&#39;],</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">          &#39;:&#39;,</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">          [[&#39;BB1&#39;], [[&#39;def&#39;, &#39;BBA&#39;, [&#39;(&#39;, &#39;)&#39;], &#39;:&#39;, [[&#39;bba1&#39;], [&#39;bba2&#39;], [&#39;bba3&#39;]]]]]],</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">         &#39;C&#39;,</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral">         &#39;D&#39;,</span></div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">         [&#39;def&#39;,</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">          &#39;spam&#39;,</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">          [&#39;(&#39;, &#39;x&#39;, &#39;y&#39;, &#39;)&#39;],</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">          &#39;:&#39;,</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral">          [[[&#39;def&#39;, &#39;eggs&#39;, [&#39;(&#39;, &#39;z&#39;, &#39;)&#39;], &#39;:&#39;, [[&#39;pass&#39;]]]]]]]</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  943</span>    backup_stacks.append(indentStack[:])</div>
<div class="line"><span class="lineno">  944</span> </div>
<div class="line"><span class="lineno">  945</span>    <span class="keyword">def </span>reset_stack():</div>
<div class="line"><span class="lineno">  946</span>        indentStack[:] = backup_stacks[-1]</div>
<div class="line"><span class="lineno">  947</span> </div>
<div class="line"><span class="lineno">  948</span>    <span class="keyword">def </span>checkPeerIndent(s, l, t):</div>
<div class="line"><span class="lineno">  949</span>        <span class="keywordflow">if</span> l &gt;= len(s):</div>
<div class="line"><span class="lineno">  950</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  951</span>        curCol = col(l, s)</div>
<div class="line"><span class="lineno">  952</span>        <span class="keywordflow">if</span> curCol != indentStack[-1]:</div>
<div class="line"><span class="lineno">  953</span>            <span class="keywordflow">if</span> curCol &gt; indentStack[-1]:</div>
<div class="line"><span class="lineno">  954</span>                <span class="keywordflow">raise</span> ParseException(s, l, <span class="stringliteral">&quot;illegal nesting&quot;</span>)</div>
<div class="line"><span class="lineno">  955</span>            <span class="keywordflow">raise</span> ParseException(s, l, <span class="stringliteral">&quot;not a peer entry&quot;</span>)</div>
<div class="line"><span class="lineno">  956</span> </div>
<div class="line"><span class="lineno">  957</span>    <span class="keyword">def </span>checkSubIndent(s, l, t):</div>
<div class="line"><span class="lineno">  958</span>        curCol = col(l, s)</div>
<div class="line"><span class="lineno">  959</span>        <span class="keywordflow">if</span> curCol &gt; indentStack[-1]:</div>
<div class="line"><span class="lineno">  960</span>            indentStack.append(curCol)</div>
<div class="line"><span class="lineno">  961</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  962</span>            <span class="keywordflow">raise</span> ParseException(s, l, <span class="stringliteral">&quot;not a subentry&quot;</span>)</div>
<div class="line"><span class="lineno">  963</span> </div>
<div class="line"><span class="lineno">  964</span>    <span class="keyword">def </span>checkUnindent(s, l, t):</div>
<div class="line"><span class="lineno">  965</span>        <span class="keywordflow">if</span> l &gt;= len(s):</div>
<div class="line"><span class="lineno">  966</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  967</span>        curCol = col(l, s)</div>
<div class="line"><span class="lineno">  968</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (indentStack <span class="keywordflow">and</span> curCol <span class="keywordflow">in</span> indentStack):</div>
<div class="line"><span class="lineno">  969</span>            <span class="keywordflow">raise</span> ParseException(s, l, <span class="stringliteral">&quot;not an unindent&quot;</span>)</div>
<div class="line"><span class="lineno">  970</span>        <span class="keywordflow">if</span> curCol &lt; indentStack[-1]:</div>
<div class="line"><span class="lineno">  971</span>            indentStack.pop()</div>
<div class="line"><span class="lineno">  972</span> </div>
<div class="line"><span class="lineno">  973</span>    NL = OneOrMore(LineEnd().set_whitespace_chars(<span class="stringliteral">&quot;\t &quot;</span>).suppress())</div>
<div class="line"><span class="lineno">  974</span>    INDENT = (Empty() + Empty().set_parse_action(checkSubIndent)).set_name(<span class="stringliteral">&quot;INDENT&quot;</span>)</div>
<div class="line"><span class="lineno">  975</span>    PEER = Empty().set_parse_action(checkPeerIndent).set_name(<span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><span class="lineno">  976</span>    UNDENT = Empty().set_parse_action(checkUnindent).set_name(<span class="stringliteral">&quot;UNINDENT&quot;</span>)</div>
<div class="line"><span class="lineno">  977</span>    <span class="keywordflow">if</span> indent:</div>
<div class="line"><span class="lineno">  978</span>        smExpr = Group(</div>
<div class="line"><span class="lineno">  979</span>            Opt(NL)</div>
<div class="line"><span class="lineno">  980</span>            + INDENT</div>
<div class="line"><span class="lineno">  981</span>            + OneOrMore(PEER + Group(blockStatementExpr) + Opt(NL))</div>
<div class="line"><span class="lineno">  982</span>            + UNDENT</div>
<div class="line"><span class="lineno">  983</span>        )</div>
<div class="line"><span class="lineno">  984</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  985</span>        smExpr = Group(</div>
<div class="line"><span class="lineno">  986</span>            Opt(NL)</div>
<div class="line"><span class="lineno">  987</span>            + OneOrMore(PEER + Group(blockStatementExpr) + Opt(NL))</div>
<div class="line"><span class="lineno">  988</span>            + Opt(UNDENT)</div>
<div class="line"><span class="lineno">  989</span>        )</div>
<div class="line"><span class="lineno">  990</span> </div>
<div class="line"><span class="lineno">  991</span>    <span class="comment"># add a parse action to remove backup_stack from list of backups</span></div>
<div class="line"><span class="lineno">  992</span>    smExpr.add_parse_action(</div>
<div class="line"><span class="lineno">  993</span>        <span class="keyword">lambda</span>: backup_stacks.pop(-1) <span class="keywordflow">and</span> <span class="keywordtype">None</span> <span class="keywordflow">if</span> backup_stacks <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  994</span>    )</div>
<div class="line"><span class="lineno">  995</span>    smExpr.set_fail_action(<span class="keyword">lambda</span> a, b, c, d: reset_stack())</div>
<div class="line"><span class="lineno">  996</span>    blockStatementExpr.ignore(_bslash + LineEnd())</div>
<div class="line"><span class="lineno">  997</span>    <span class="keywordflow">return</span> smExpr.set_name(<span class="stringliteral">&quot;indented block&quot;</span>)</div>
<div class="line"><span class="lineno">  998</span> </div>
<div class="line"><span class="lineno">  999</span> </div>
<div class="line"><span class="lineno"> 1000</span><span class="comment"># it&#39;s easy to get these comment structures wrong - they&#39;re very common, so may as well make them available</span></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../d6/d63/pyparsing_2util_8py_source.html#l00040">pip._vendor.pyparsing.util.col()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_ad41b53e5d3582308e6e8de5a5827d722_cgraph.png" border="0" usemap="#ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_ad41b53e5d3582308e6e8de5a5827d722_cgraph" loading="lazy" alt=""/></div>
<map name="ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_ad41b53e5d3582308e6e8de5a5827d722_cgraph" id="ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_ad41b53e5d3582308e6e8de5a5827d722_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,109,32"/>
<area shape="rect" href="../../d3/db1/namespacepip_1_1__vendor_1_1pyparsing_1_1util.html#aeba8e79de9dfc9d307cbc81d8e40a65a" title=" " alt="" coords="157,5,347,32"/>
<area shape="poly" title=" " alt="" coords="109,16,141,16,141,21,109,21"/>
</map>
</div>

</div>
</div>
<a id="a218fd6c8f356e0b02c13805b7fc1cf99" name="a218fd6c8f356e0b02c13805b7fc1cf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218fd6c8f356e0b02c13805b7fc1cf99">&#9670;&#160;</a></span>infix_notation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> infix_notation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a></td>          <td class="paramname"><span class="paramname"><em>base_expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List[<a class="el" href="#a732829e9bcf9affdfe67f35af42c0915">InfixNotationOperatorSpec</a>]</td>          <td class="paramname"><span class="paramname"><em>op_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] </td>          <td class="paramname"><span class="paramname"><em>lpar</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d99/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_suppress.html">Suppress</a>(&quot;(&quot;)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] </td>          <td class="paramname"><span class="paramname"><em>rpar</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../d8/d99/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_suppress.html">Suppress</a>(&quot;)&quot;)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper method for constructing grammars of expressions made up of
operators working in a precedence hierarchy.  Operators may be unary
or binary, left- or right-associative.  Parse actions can also be
attached to operator expressions. The generated parser will also
recognize the use of parentheses to override operator precedences
(see example below).

Note: if you define a deep operator list, you may see performance
issues when using infix_notation. See
:class:`ParserElement.enable_packrat` for a mechanism to potentially
improve your parser performance.

Parameters:

- ``base_expr`` - expression representing the most basic operand to
  be used in the expression
- ``op_list`` - list of tuples, one for each operator precedence level
  in the expression grammar; each tuple is of the form ``(op_expr,
  num_operands, right_left_assoc, (optional)parse_action)``, where:

  - ``op_expr`` is the pyparsing expression for the operator; may also
    be a string, which will be converted to a Literal; if ``num_operands``
    is 3, ``op_expr`` is a tuple of two expressions, for the two
    operators separating the 3 terms
  - ``num_operands`` is the number of terms for this operator (must be 1,
    2, or 3)
  - ``right_left_assoc`` is the indicator whether the operator is right
    or left associative, using the pyparsing-defined constants
    ``OpAssoc.RIGHT`` and ``OpAssoc.LEFT``.
  - ``parse_action`` is the parse action to be associated with
    expressions matching this operator expression (the parse action
    tuple member may be omitted); if the parse action is passed
    a tuple or list of functions, this is equivalent to calling
    ``set_parse_action(*fn)``
    (:class:`ParserElement.set_parse_action`)
- ``lpar`` - expression for matching left-parentheses; if passed as a
  str, then will be parsed as ``Suppress(lpar)``. If lpar is passed as
  an expression (such as ``Literal('(')``), then it will be kept in
  the parsed results, and grouped with them. (default= ``Suppress('(')``)
- ``rpar`` - expression for matching right-parentheses; if passed as a
  str, then will be parsed as ``Suppress(rpar)``. If rpar is passed as
  an expression (such as ``Literal(')')``), then it will be kept in
  the parsed results, and grouped with them. (default= ``Suppress(')')``)

Example::

    # simple example of four-function arithmetic with ints and
    # variable names
    integer = pyparsing_common.signed_integer
    varname = pyparsing_common.identifier

    arith_expr = infix_notation(integer | varname,
        [
        ('-', 1, OpAssoc.RIGHT),
        (one_of('* /'), 2, OpAssoc.LEFT),
        (one_of('+ -'), 2, OpAssoc.LEFT),
        ])

    arith_expr.run_tests('''
        5+3*6
        (5+3)*6
        -2--11
        ''', full_dump=False)

prints::

    5+3*6
    [[5, '+', [3, '*', 6]]]

    (5+3)*6
    [[[5, '+', 3], '*', 6]]

    (5+x)*y
    [[[5, '+', 'x'], '*', 'y']]

    -2--11
    [[['-', 2], '-', ['-', 11]]]
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00680">680</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  685</span>) -&gt; ParserElement:</div>
<div class="line"><span class="lineno">  686</span>    <span class="stringliteral">&quot;&quot;&quot;Helper method for constructing grammars of expressions made up of</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">    operators working in a precedence hierarchy.  Operators may be unary</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    or binary, left- or right-associative.  Parse actions can also be</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">    attached to operator expressions. The generated parser will also</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    recognize the use of parentheses to override operator precedences</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    (see example below).</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    Note: if you define a deep operator list, you may see performance</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    issues when using infix_notation. See</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    :class:`ParserElement.enable_packrat` for a mechanism to potentially</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">    improve your parser performance.</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">    Parameters:</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">    - ``base_expr`` - expression representing the most basic operand to</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">      be used in the expression</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">    - ``op_list`` - list of tuples, one for each operator precedence level</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">      in the expression grammar; each tuple is of the form ``(op_expr,</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">      num_operands, right_left_assoc, (optional)parse_action)``, where:</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">      - ``op_expr`` is the pyparsing expression for the operator; may also</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">        be a string, which will be converted to a Literal; if ``num_operands``</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">        is 3, ``op_expr`` is a tuple of two expressions, for the two</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">        operators separating the 3 terms</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">      - ``num_operands`` is the number of terms for this operator (must be 1,</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">        2, or 3)</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">      - ``right_left_assoc`` is the indicator whether the operator is right</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">        or left associative, using the pyparsing-defined constants</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">        ``OpAssoc.RIGHT`` and ``OpAssoc.LEFT``.</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">      - ``parse_action`` is the parse action to be associated with</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">        expressions matching this operator expression (the parse action</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">        tuple member may be omitted); if the parse action is passed</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">        a tuple or list of functions, this is equivalent to calling</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">        ``set_parse_action(*fn)``</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">        (:class:`ParserElement.set_parse_action`)</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">    - ``lpar`` - expression for matching left-parentheses; if passed as a</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">      str, then will be parsed as ``Suppress(lpar)``. If lpar is passed as</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">      an expression (such as ``Literal(&#39;(&#39;)``), then it will be kept in</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">      the parsed results, and grouped with them. (default= ``Suppress(&#39;(&#39;)``)</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">    - ``rpar`` - expression for matching right-parentheses; if passed as a</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">      str, then will be parsed as ``Suppress(rpar)``. If rpar is passed as</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">      an expression (such as ``Literal(&#39;)&#39;)``), then it will be kept in</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">      the parsed results, and grouped with them. (default= ``Suppress(&#39;)&#39;)``)</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    Example::</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">        # simple example of four-function arithmetic with ints and</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">        # variable names</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">        integer = pyparsing_common.signed_integer</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">        varname = pyparsing_common.identifier</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">        arith_expr = infix_notation(integer | varname,</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">            [</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">            (&#39;-&#39;, 1, OpAssoc.RIGHT),</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">            (one_of(&#39;* /&#39;), 2, OpAssoc.LEFT),</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">            (one_of(&#39;+ -&#39;), 2, OpAssoc.LEFT),</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">            ])</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">        arith_expr.run_tests(&#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">            5+3*6</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">            (5+3)*6</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">            -2--11</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">            &#39;&#39;&#39;, full_dump=False)</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    prints::</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">        5+3*6</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">        [[5, &#39;+&#39;, [3, &#39;*&#39;, 6]]]</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">        (5+3)*6</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">        [[[5, &#39;+&#39;, 3], &#39;*&#39;, 6]]</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">        (5+x)*y</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">        [[[5, &#39;+&#39;, &#39;x&#39;], &#39;*&#39;, &#39;y&#39;]]</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">        -2--11</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">        [[[&#39;-&#39;, 2], &#39;-&#39;, [&#39;-&#39;, 11]]]</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  764</span> </div>
<div class="line"><span class="lineno">  765</span>    <span class="comment"># captive version of FollowedBy that does not do parse actions or capture results names</span></div>
<div class="line"><span class="lineno">  766</span>    <span class="keyword">class </span>_FB(FollowedBy):</div>
<div class="line"><span class="lineno">  767</span>        <span class="keyword">def </span>parseImpl(self, instring, loc, doActions=True):</div>
<div class="line"><span class="lineno">  768</span>            self.expr.try_parse(instring, loc)</div>
<div class="line"><span class="lineno">  769</span>            <span class="keywordflow">return</span> loc, []</div>
<div class="line"><span class="lineno">  770</span> </div>
<div class="line"><span class="lineno">  771</span>    _FB.__name__ = <span class="stringliteral">&quot;FollowedBy&gt;&quot;</span></div>
<div class="line"><span class="lineno">  772</span> </div>
<div class="line"><span class="lineno">  773</span>    ret = Forward()</div>
<div class="line"><span class="lineno">  774</span>    <span class="keywordflow">if</span> isinstance(lpar, str):</div>
<div class="line"><span class="lineno">  775</span>        lpar = Suppress(lpar)</div>
<div class="line"><span class="lineno">  776</span>    <span class="keywordflow">if</span> isinstance(rpar, str):</div>
<div class="line"><span class="lineno">  777</span>        rpar = Suppress(rpar)</div>
<div class="line"><span class="lineno">  778</span> </div>
<div class="line"><span class="lineno">  779</span>    <span class="comment"># if lpar and rpar are not suppressed, wrap in group</span></div>
<div class="line"><span class="lineno">  780</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> (isinstance(rpar, Suppress) <span class="keywordflow">and</span> isinstance(rpar, Suppress)):</div>
<div class="line"><span class="lineno">  781</span>        lastExpr = base_expr | Group(lpar + ret + rpar)</div>
<div class="line"><span class="lineno">  782</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  783</span>        lastExpr = base_expr | (lpar + ret + rpar)</div>
<div class="line"><span class="lineno">  784</span> </div>
<div class="line"><span class="lineno">  785</span>    arity: int</div>
<div class="line"><span class="lineno">  786</span>    rightLeftAssoc: opAssoc</div>
<div class="line"><span class="lineno">  787</span>    pa: typing.Optional[ParseAction]</div>
<div class="line"><span class="lineno">  788</span>    opExpr1: ParserElement</div>
<div class="line"><span class="lineno">  789</span>    opExpr2: ParserElement</div>
<div class="line"><span class="lineno">  790</span>    <span class="keywordflow">for</span> i, operDef <span class="keywordflow">in</span> enumerate(op_list):</div>
<div class="line"><span class="lineno">  791</span>        opExpr, arity, rightLeftAssoc, pa = (operDef + (<span class="keywordtype">None</span>,))[:4]  <span class="comment"># type: ignore[assignment]</span></div>
<div class="line"><span class="lineno">  792</span>        <span class="keywordflow">if</span> isinstance(opExpr, str_type):</div>
<div class="line"><span class="lineno">  793</span>            opExpr = ParserElement._literalStringClass(opExpr)</div>
<div class="line"><span class="lineno">  794</span>        opExpr = typing.cast(ParserElement, opExpr)</div>
<div class="line"><span class="lineno">  795</span>        <span class="keywordflow">if</span> arity == 3:</div>
<div class="line"><span class="lineno">  796</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(opExpr, (tuple, list)) <span class="keywordflow">or</span> len(opExpr) != 2:</div>
<div class="line"><span class="lineno">  797</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  798</span>                    <span class="stringliteral">&quot;if numterms=3, opExpr must be a tuple or list of two expressions&quot;</span></div>
<div class="line"><span class="lineno">  799</span>                )</div>
<div class="line"><span class="lineno">  800</span>            opExpr1, opExpr2 = opExpr</div>
<div class="line"><span class="lineno">  801</span>            term_name = f<span class="stringliteral">&quot;{opExpr1}{opExpr2} term&quot;</span></div>
<div class="line"><span class="lineno">  802</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  803</span>            term_name = f<span class="stringliteral">&quot;{opExpr} term&quot;</span></div>
<div class="line"><span class="lineno">  804</span> </div>
<div class="line"><span class="lineno">  805</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> 1 &lt;= arity &lt;= 3:</div>
<div class="line"><span class="lineno">  806</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;operator must be unary (1), binary (2), or ternary (3)&quot;</span>)</div>
<div class="line"><span class="lineno">  807</span> </div>
<div class="line"><span class="lineno">  808</span>        <span class="keywordflow">if</span> rightLeftAssoc <span class="keywordflow">not</span> <span class="keywordflow">in</span> (OpAssoc.LEFT, OpAssoc.RIGHT):</div>
<div class="line"><span class="lineno">  809</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;operator must indicate right or left associativity&quot;</span>)</div>
<div class="line"><span class="lineno">  810</span> </div>
<div class="line"><span class="lineno">  811</span>        thisExpr: ParserElement = Forward().set_name(term_name)</div>
<div class="line"><span class="lineno">  812</span>        thisExpr = typing.cast(Forward, thisExpr)</div>
<div class="line"><span class="lineno">  813</span>        <span class="keywordflow">if</span> rightLeftAssoc <span class="keywordflow">is</span> OpAssoc.LEFT:</div>
<div class="line"><span class="lineno">  814</span>            <span class="keywordflow">if</span> arity == 1:</div>
<div class="line"><span class="lineno">  815</span>                matchExpr = _FB(lastExpr + opExpr) + Group(lastExpr + opExpr[1, ...])</div>
<div class="line"><span class="lineno">  816</span>            <span class="keywordflow">elif</span> arity == 2:</div>
<div class="line"><span class="lineno">  817</span>                <span class="keywordflow">if</span> opExpr <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  818</span>                    matchExpr = _FB(lastExpr + opExpr + lastExpr) + Group(</div>
<div class="line"><span class="lineno">  819</span>                        lastExpr + (opExpr + lastExpr)[1, ...]</div>
<div class="line"><span class="lineno">  820</span>                    )</div>
<div class="line"><span class="lineno">  821</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  822</span>                    matchExpr = _FB(lastExpr + lastExpr) + Group(lastExpr[2, ...])</div>
<div class="line"><span class="lineno">  823</span>            <span class="keywordflow">elif</span> arity == 3:</div>
<div class="line"><span class="lineno">  824</span>                matchExpr = _FB(</div>
<div class="line"><span class="lineno">  825</span>                    lastExpr + opExpr1 + lastExpr + opExpr2 + lastExpr</div>
<div class="line"><span class="lineno">  826</span>                ) + Group(lastExpr + OneOrMore(opExpr1 + lastExpr + opExpr2 + lastExpr))</div>
<div class="line"><span class="lineno">  827</span>        <span class="keywordflow">elif</span> rightLeftAssoc <span class="keywordflow">is</span> OpAssoc.RIGHT:</div>
<div class="line"><span class="lineno">  828</span>            <span class="keywordflow">if</span> arity == 1:</div>
<div class="line"><span class="lineno">  829</span>                <span class="comment"># try to avoid LR with this extra test</span></div>
<div class="line"><span class="lineno">  830</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(opExpr, Opt):</div>
<div class="line"><span class="lineno">  831</span>                    opExpr = Opt(opExpr)</div>
<div class="line"><span class="lineno">  832</span>                matchExpr = _FB(opExpr.expr + thisExpr) + Group(opExpr + thisExpr)</div>
<div class="line"><span class="lineno">  833</span>            <span class="keywordflow">elif</span> arity == 2:</div>
<div class="line"><span class="lineno">  834</span>                <span class="keywordflow">if</span> opExpr <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  835</span>                    matchExpr = _FB(lastExpr + opExpr + thisExpr) + Group(</div>
<div class="line"><span class="lineno">  836</span>                        lastExpr + (opExpr + thisExpr)[1, ...]</div>
<div class="line"><span class="lineno">  837</span>                    )</div>
<div class="line"><span class="lineno">  838</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  839</span>                    matchExpr = _FB(lastExpr + thisExpr) + Group(</div>
<div class="line"><span class="lineno">  840</span>                        lastExpr + thisExpr[1, ...]</div>
<div class="line"><span class="lineno">  841</span>                    )</div>
<div class="line"><span class="lineno">  842</span>            <span class="keywordflow">elif</span> arity == 3:</div>
<div class="line"><span class="lineno">  843</span>                matchExpr = _FB(</div>
<div class="line"><span class="lineno">  844</span>                    lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr</div>
<div class="line"><span class="lineno">  845</span>                ) + Group(lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr)</div>
<div class="line"><span class="lineno">  846</span>        <span class="keywordflow">if</span> pa:</div>
<div class="line"><span class="lineno">  847</span>            <span class="keywordflow">if</span> isinstance(pa, (tuple, list)):</div>
<div class="line"><span class="lineno">  848</span>                matchExpr.set_parse_action(*pa)</div>
<div class="line"><span class="lineno">  849</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  850</span>                matchExpr.set_parse_action(pa)</div>
<div class="line"><span class="lineno">  851</span>        thisExpr &lt;&lt;= (matchExpr | lastExpr).setName(term_name)</div>
<div class="line"><span class="lineno">  852</span>        lastExpr = thisExpr</div>
<div class="line"><span class="lineno">  853</span>    ret &lt;&lt;= lastExpr</div>
<div class="line"><span class="lineno">  854</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno">  855</span> </div>
<div class="line"><span class="lineno">  856</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afa06862d0f9515a0100e15a14738b0c0" name="afa06862d0f9515a0100e15a14738b0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa06862d0f9515a0100e15a14738b0c0">&#9670;&#160;</a></span>infixNotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">infixNotation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01099">1099</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1099</span><span class="keyword">def </span>infixNotation(): ...</div>
<div class="line"><span class="lineno"> 1100</span><span class="comment"># fmt: on</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b2dc27e553a663c0a256fb76cb4c5b6" name="a8b2dc27e553a663c0a256fb76cb4c5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2dc27e553a663c0a256fb76cb4c5b6">&#9670;&#160;</a></span>locatedExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> locatedExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">(DEPRECATED - future code should use the :class:`Located` class)
Helper to decorate a returned token with its starting and ending
locations in the input string.

This helper adds the following results names:

- ``locn_start`` - location where matched expression begins
- ``locn_end`` - location where matched expression ends
- ``value`` - the actual parsed results

Be careful if the input text contains ``&lt;TAB&gt;`` characters, you
may want to call :class:`ParserElement.parse_with_tabs`

Example::

    wd = Word(alphas)
    for match in locatedExpr(wd).search_string("ljsdf123lksdjjf123lkkjj1222"):
        print(match)

prints::

    [[0, 'ljsdf', 5]]
    [[8, 'lksdjjf', 15]]
    [[18, 'lkkjj', 23]]
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00375">375</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  375</span><span class="keyword">def </span>locatedExpr(expr: ParserElement) -&gt; ParserElement:</div>
<div class="line"><span class="lineno">  376</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">    (DEPRECATED - future code should use the :class:`Located` class)</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    Helper to decorate a returned token with its starting and ending</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    locations in the input string.</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    This helper adds the following results names:</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    - ``locn_start`` - location where matched expression begins</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">    - ``locn_end`` - location where matched expression ends</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    - ``value`` - the actual parsed results</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    Be careful if the input text contains ``&lt;TAB&gt;`` characters, you</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    may want to call :class:`ParserElement.parse_with_tabs`</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    Example::</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">        wd = Word(alphas)</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">        for match in locatedExpr(wd).search_string(&quot;ljsdf123lksdjjf123lkkjj1222&quot;):</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">            print(match)</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    prints::</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">        [[0, &#39;ljsdf&#39;, 5]]</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral">        [[8, &#39;lksdjjf&#39;, 15]]</span></div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">        [[18, &#39;lkkjj&#39;, 23]]</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  402</span>    locator = Empty().set_parse_action(<span class="keyword">lambda</span> ss, ll, tt: ll)</div>
<div class="line"><span class="lineno">  403</span>    <span class="keywordflow">return</span> Group(</div>
<div class="line"><span class="lineno">  404</span>        locator(<span class="stringliteral">&quot;locn_start&quot;</span>)</div>
<div class="line"><span class="lineno">  405</span>        + expr(<span class="stringliteral">&quot;value&quot;</span>)</div>
<div class="line"><span class="lineno">  406</span>        + locator.copy().leaveWhitespace()(<span class="stringliteral">&quot;locn_end&quot;</span>)</div>
<div class="line"><span class="lineno">  407</span>    )</div>
<div class="line"><span class="lineno">  408</span> </div>
<div class="line"><span class="lineno">  409</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a780336396004a526fa5caedd9b204a98" name="a780336396004a526fa5caedd9b204a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780336396004a526fa5caedd9b204a98">&#9670;&#160;</a></span>make_html_tags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] make_html_tags </td>
          <td>(</td>
          <td class="paramtype">Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>]
</td>          <td class="paramname"><span class="paramname"><em>tag_str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper to construct opening and closing tag expressions for HTML,
given a tag name. Matches tags in either upper or lower case,
attributes with namespaces and with quoted or unquoted values.

Example::

    text = '&lt;td&gt;More info at the &lt;a href="https://github.com/pyparsing/pyparsing/wiki"&gt;pyparsing&lt;/a&gt; wiki page&lt;/td&gt;'
    # make_html_tags returns pyparsing expressions for the opening and
    # closing tags as a 2-tuple
    a, a_end = make_html_tags("A")
    link_expr = a + SkipTo(a_end)("link_text") + a_end

    for link in link_expr.search_string(text):
        # attributes in the &lt;A&gt; tag (like "href" shown here) are
        # also accessible as named results
        print(link.link_text, '-&gt;', link.href)

prints::

    pyparsing -&gt; https://github.com/pyparsing/pyparsing/wiki
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00599">599</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  601</span>) -&gt; Tuple[ParserElement, ParserElement]:</div>
<div class="line"><span class="lineno">  602</span>    <span class="stringliteral">&quot;&quot;&quot;Helper to construct opening and closing tag expressions for HTML,</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">    given a tag name. Matches tags in either upper or lower case,</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">    attributes with namespaces and with quoted or unquoted values.</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    Example::</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">        text = &#39;&lt;td&gt;More info at the &lt;a href=&quot;https://github.com/pyparsing/pyparsing/wiki&quot;&gt;pyparsing&lt;/a&gt; wiki page&lt;/td&gt;&#39;</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">        # make_html_tags returns pyparsing expressions for the opening and</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral">        # closing tags as a 2-tuple</span></div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">        a, a_end = make_html_tags(&quot;A&quot;)</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">        link_expr = a + SkipTo(a_end)(&quot;link_text&quot;) + a_end</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">        for link in link_expr.search_string(text):</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">            # attributes in the &lt;A&gt; tag (like &quot;href&quot; shown here) are</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral">            # also accessible as named results</span></div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">            print(link.link_text, &#39;-&gt;&#39;, link.href)</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral">    prints::</span></div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">        pyparsing -&gt; https://github.com/pyparsing/pyparsing/wiki</span></div>
<div class="line"><span class="lineno">  622</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  623</span>    <span class="keywordflow">return</span> _makeTags(tag_str, <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  624</span> </div>
<div class="line"><span class="lineno">  625</span> </div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../d2/deb/helpers_8py_source.html#l00541">_makeTags()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_a780336396004a526fa5caedd9b204a98_cgraph.png" border="0" usemap="#ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_a780336396004a526fa5caedd9b204a98_cgraph" loading="lazy" alt=""/></div>
<map name="ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_a780336396004a526fa5caedd9b204a98_cgraph" id="ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_a780336396004a526fa5caedd9b204a98_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,123,32"/>
<area shape="rect" href="../../d8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers.html#ada515ee172e0f92aaa93f7be47f0f93e" title=" " alt="" coords="171,5,259,32"/>
<area shape="poly" title=" " alt="" coords="123,16,155,16,155,21,123,21"/>
</map>
</div>

</div>
</div>
<a id="a128b9c58053ca5b54aac0e1ee646570a" name="a128b9c58053ca5b54aac0e1ee646570a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128b9c58053ca5b54aac0e1ee646570a">&#9670;&#160;</a></span>make_xml_tags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] make_xml_tags </td>
          <td>(</td>
          <td class="paramtype">Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>]
</td>          <td class="paramname"><span class="paramname"><em>tag_str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper to construct opening and closing tag expressions for XML,
given a tag name. Matches tags only in the given upper/lower case.

Example: similar to :class:`make_html_tags`
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00626">626</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  628</span>) -&gt; Tuple[ParserElement, ParserElement]:</div>
<div class="line"><span class="lineno">  629</span>    <span class="stringliteral">&quot;&quot;&quot;Helper to construct opening and closing tag expressions for XML,</span></div>
<div class="line"><span class="lineno">  630</span><span class="stringliteral">    given a tag name. Matches tags only in the given upper/lower case.</span></div>
<div class="line"><span class="lineno">  631</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  632</span><span class="stringliteral">    Example: similar to :class:`make_html_tags`</span></div>
<div class="line"><span class="lineno">  633</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  634</span>    <span class="keywordflow">return</span> _makeTags(tag_str, <span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  635</span> </div>
<div class="line"><span class="lineno">  636</span> </div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../d2/deb/helpers_8py_source.html#l00541">_makeTags()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_a128b9c58053ca5b54aac0e1ee646570a_cgraph.png" border="0" usemap="#ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_a128b9c58053ca5b54aac0e1ee646570a_cgraph" loading="lazy" alt=""/></div>
<map name="ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_a128b9c58053ca5b54aac0e1ee646570a_cgraph" id="ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_a128b9c58053ca5b54aac0e1ee646570a_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,119,32"/>
<area shape="rect" href="../../d8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers.html#ada515ee172e0f92aaa93f7be47f0f93e" title=" " alt="" coords="167,5,255,32"/>
<area shape="poly" title=" " alt="" coords="119,16,151,16,151,21,119,21"/>
</map>
</div>

</div>
</div>
<a id="a932a8ac714a4d119ef2eefd4a96e64ab" name="a932a8ac714a4d119ef2eefd4a96e64ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932a8ac714a4d119ef2eefd4a96e64ab">&#9670;&#160;</a></span>makeHTMLTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">makeHTMLTags </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01090">1090</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1090</span><span class="keyword">def </span>makeHTMLTags(): ...</div>
<div class="line"><span class="lineno"> 1091</span> </div>
<div class="line"><span class="lineno"> 1092</span><span class="preprocessor">@replaced_by_pep8(make_xml_tags)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a93a25b14d1f9abbe6418cb2035652abf" name="a93a25b14d1f9abbe6418cb2035652abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a25b14d1f9abbe6418cb2035652abf">&#9670;&#160;</a></span>makeXMLTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">makeXMLTags </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01093">1093</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1093</span><span class="keyword">def </span>makeXMLTags(): ...</div>
<div class="line"><span class="lineno"> 1094</span> </div>
<div class="line"><span class="lineno"> 1095</span><span class="preprocessor">@replaced_by_pep8(replace_html_entity)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="aea316bc5f32af937c8c4a3735c81c4b0" name="aea316bc5f32af937c8c4a3735c81c4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea316bc5f32af937c8c4a3735c81c4b0">&#9670;&#160;</a></span>match_previous_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> match_previous_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper to define an expression that is indirectly defined from
the tokens matched in a previous expression, that is, it looks for
a 'repeat' of a previous expression.  For example::

    first = Word(nums)
    second = match_previous_expr(first)
    match_expr = first + ":" + second

will match ``"1:1"``, but not ``"1:2"``.  Because this
matches by expressions, will *not* match the leading ``"1:1"``
in ``"1:10"``; the expressions are evaluated first, and then
compared, so ``"1"`` is compared with ``"10"``. Do *not* use
with packrat parsing enabled.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00113">113</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  113</span><span class="keyword">def </span>match_previous_expr(expr: ParserElement) -&gt; ParserElement:</div>
<div class="line"><span class="lineno">  114</span>    <span class="stringliteral">&quot;&quot;&quot;Helper to define an expression that is indirectly defined from</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    the tokens matched in a previous expression, that is, it looks for</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    a &#39;repeat&#39; of a previous expression.  For example::</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">        first = Word(nums)</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">        second = match_previous_expr(first)</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">        match_expr = first + &quot;:&quot; + second</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    will match ``&quot;1:1&quot;``, but not ``&quot;1:2&quot;``.  Because this</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    matches by expressions, will *not* match the leading ``&quot;1:1&quot;``</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    in ``&quot;1:10&quot;``; the expressions are evaluated first, and then</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    compared, so ``&quot;1&quot;`` is compared with ``&quot;10&quot;``. Do *not* use</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    with packrat parsing enabled.</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  128</span>    rep = Forward()</div>
<div class="line"><span class="lineno">  129</span>    e2 = expr.copy()</div>
<div class="line"><span class="lineno">  130</span>    rep &lt;&lt;= e2</div>
<div class="line"><span class="lineno">  131</span> </div>
<div class="line"><span class="lineno">  132</span>    <span class="keyword">def </span>copy_token_to_repeater(s, l, t):</div>
<div class="line"><span class="lineno">  133</span>        matchTokens = _flatten(t.as_list())</div>
<div class="line"><span class="lineno">  134</span> </div>
<div class="line"><span class="lineno">  135</span>        <span class="keyword">def </span>must_match_these_tokens(s, l, t):</div>
<div class="line"><span class="lineno">  136</span>            theseTokens = _flatten(t.as_list())</div>
<div class="line"><span class="lineno">  137</span>            <span class="keywordflow">if</span> theseTokens != matchTokens:</div>
<div class="line"><span class="lineno">  138</span>                <span class="keywordflow">raise</span> ParseException(</div>
<div class="line"><span class="lineno">  139</span>                    s, l, f<span class="stringliteral">&quot;Expected {matchTokens}, found{theseTokens}&quot;</span></div>
<div class="line"><span class="lineno">  140</span>                )</div>
<div class="line"><span class="lineno">  141</span> </div>
<div class="line"><span class="lineno">  142</span>        rep.set_parse_action(must_match_these_tokens, callDuringTry=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  143</span> </div>
<div class="line"><span class="lineno">  144</span>    expr.add_parse_action(copy_token_to_repeater, callDuringTry=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  145</span>    rep.set_name(<span class="stringliteral">&quot;(prev) &quot;</span> + str(expr))</div>
<div class="line"><span class="lineno">  146</span>    <span class="keywordflow">return</span> rep</div>
<div class="line"><span class="lineno">  147</span> </div>
<div class="line"><span class="lineno">  148</span> </div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../d6/d63/pyparsing_2util_8py_source.html#l00230">pip._vendor.pyparsing.util._flatten()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_aea316bc5f32af937c8c4a3735c81c4b0_cgraph.png" border="0" usemap="#ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_aea316bc5f32af937c8c4a3735c81c4b0_cgraph" loading="lazy" alt=""/></div>
<map name="ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_aea316bc5f32af937c8c4a3735c81c4b0_cgraph" id="ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_aea316bc5f32af937c8c4a3735c81c4b0_cgraph">
<area shape="rect" title=" " alt="" coords="5,37,151,64"/>
<area shape="rect" href="../../d3/db1/namespacepip_1_1__vendor_1_1pyparsing_1_1util.html#a19ad708809999acb93388f41f3f12b44" title=" " alt="" coords="199,29,372,72"/>
<area shape="poly" title=" " alt="" coords="151,48,183,48,183,53,151,53"/>
<area shape="poly" title=" " alt="" coords="246,29,244,19,251,10,265,5,285,3,308,5,321,11,319,16,306,10,285,8,266,10,254,15,249,21,251,28"/>
</map>
</div>

</div>
</div>
<a id="ada847ea890ad0539072827b2b01eb826" name="ada847ea890ad0539072827b2b01eb826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada847ea890ad0539072827b2b01eb826">&#9670;&#160;</a></span>match_previous_literal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> match_previous_literal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper to define an expression that is indirectly defined from
the tokens matched in a previous expression, that is, it looks for
a 'repeat' of a previous expression.  For example::

    first = Word(nums)
    second = match_previous_literal(first)
    match_expr = first + ":" + second

will match ``"1:1"``, but not ``"1:2"``.  Because this
matches a previous literal, will also match the leading
``"1:1"`` in ``"1:10"``. If this is not desired, use
:class:`match_previous_expr`. Do *not* use with packrat parsing
enabled.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00080">80</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   80</span><span class="keyword">def </span>match_previous_literal(expr: ParserElement) -&gt; ParserElement:</div>
<div class="line"><span class="lineno">   81</span>    <span class="stringliteral">&quot;&quot;&quot;Helper to define an expression that is indirectly defined from</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">    the tokens matched in a previous expression, that is, it looks for</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    a &#39;repeat&#39; of a previous expression.  For example::</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">        first = Word(nums)</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">        second = match_previous_literal(first)</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">        match_expr = first + &quot;:&quot; + second</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    will match ``&quot;1:1&quot;``, but not ``&quot;1:2&quot;``.  Because this</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    matches a previous literal, will also match the leading</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    ``&quot;1:1&quot;`` in ``&quot;1:10&quot;``. If this is not desired, use</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">    :class:`match_previous_expr`. Do *not* use with packrat parsing</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    enabled.</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   95</span>    rep = Forward()</div>
<div class="line"><span class="lineno">   96</span> </div>
<div class="line"><span class="lineno">   97</span>    <span class="keyword">def </span>copy_token_to_repeater(s, l, t):</div>
<div class="line"><span class="lineno">   98</span>        <span class="keywordflow">if</span> t:</div>
<div class="line"><span class="lineno">   99</span>            <span class="keywordflow">if</span> len(t) == 1:</div>
<div class="line"><span class="lineno">  100</span>                rep &lt;&lt; t[0]</div>
<div class="line"><span class="lineno">  101</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  102</span>                <span class="comment"># flatten t tokens</span></div>
<div class="line"><span class="lineno">  103</span>                tflat = _flatten(t.as_list())</div>
<div class="line"><span class="lineno">  104</span>                rep &lt;&lt; And(Literal(tt) <span class="keywordflow">for</span> tt <span class="keywordflow">in</span> tflat)</div>
<div class="line"><span class="lineno">  105</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  106</span>            rep &lt;&lt; Empty()</div>
<div class="line"><span class="lineno">  107</span> </div>
<div class="line"><span class="lineno">  108</span>    expr.add_parse_action(copy_token_to_repeater, callDuringTry=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  109</span>    rep.set_name(<span class="stringliteral">&quot;(prev) &quot;</span> + str(expr))</div>
<div class="line"><span class="lineno">  110</span>    <span class="keywordflow">return</span> rep</div>
<div class="line"><span class="lineno">  111</span> </div>
<div class="line"><span class="lineno">  112</span> </div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../d6/d63/pyparsing_2util_8py_source.html#l00230">pip._vendor.pyparsing.util._flatten()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_ada847ea890ad0539072827b2b01eb826_cgraph.png" border="0" usemap="#ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_ada847ea890ad0539072827b2b01eb826_cgraph" loading="lazy" alt=""/></div>
<map name="ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_ada847ea890ad0539072827b2b01eb826_cgraph" id="ad8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers_ada847ea890ad0539072827b2b01eb826_cgraph">
<area shape="rect" title=" " alt="" coords="5,37,157,64"/>
<area shape="rect" href="../../d3/db1/namespacepip_1_1__vendor_1_1pyparsing_1_1util.html#a19ad708809999acb93388f41f3f12b44" title=" " alt="" coords="205,29,378,72"/>
<area shape="poly" title=" " alt="" coords="157,48,189,48,189,53,157,53"/>
<area shape="poly" title=" " alt="" coords="251,29,250,19,256,10,270,5,291,3,314,5,328,11,325,16,313,10,291,8,272,10,260,15,255,21,256,28"/>
</map>
</div>

</div>
</div>
<a id="a72893e5434dcc18e791df70fe8f9a4e2" name="a72893e5434dcc18e791df70fe8f9a4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72893e5434dcc18e791df70fe8f9a4e2">&#9670;&#160;</a></span>matchPreviousExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matchPreviousExpr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01075">1075</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1075</span><span class="keyword">def </span>matchPreviousExpr(): ...</div>
<div class="line"><span class="lineno"> 1076</span> </div>
<div class="line"><span class="lineno"> 1077</span><span class="preprocessor">@replaced_by_pep8(one_of)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a943b281daeb4781d29c9eb84035c28f1" name="a943b281daeb4781d29c9eb84035c28f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943b281daeb4781d29c9eb84035c28f1">&#9670;&#160;</a></span>matchPreviousLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matchPreviousLiteral </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01072">1072</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1072</span><span class="keyword">def </span>matchPreviousLiteral(): ...</div>
<div class="line"><span class="lineno"> 1073</span> </div>
<div class="line"><span class="lineno"> 1074</span><span class="preprocessor">@replaced_by_pep8(match_previous_expr)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a781ed9a599f578cf3104839d2fbbdfd7" name="a781ed9a599f578cf3104839d2fbbdfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781ed9a599f578cf3104839d2fbbdfd7">&#9670;&#160;</a></span>nested_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> nested_expr </td>
          <td>(</td>
          <td class="paramtype">Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] </td>          <td class="paramname"><span class="paramname"><em>opener</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;(&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[str, <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] </td>          <td class="paramname"><span class="paramname"><em>closer</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;)&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typing.Optional[<a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a>] </td>          <td class="paramname"><span class="paramname"><em>content</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> </td>          <td class="paramname"><span class="paramname"><em>ignore_expr</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../da/d31/namespacepip_1_1__vendor_1_1pyparsing_1_1core.html#a9a959fed7ee6e3337cf1a15d48fc962f">quoted_string</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> </td>          <td class="paramname"><span class="paramname"><em>ignoreExpr</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../da/d31/namespacepip_1_1__vendor_1_1pyparsing_1_1core.html#a9a959fed7ee6e3337cf1a15d48fc962f">quoted_string</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper method for defining nested lists enclosed in opening and
closing delimiters (``"("`` and ``")"`` are the default).

Parameters:

- ``opener`` - opening character for a nested list
  (default= ``"("``); can also be a pyparsing expression
- ``closer`` - closing character for a nested list
  (default= ``")"``); can also be a pyparsing expression
- ``content`` - expression for items within the nested lists
  (default= ``None``)
- ``ignore_expr`` - expression for ignoring opening and closing delimiters
  (default= :class:`quoted_string`)
- ``ignoreExpr`` - this pre-PEP8 argument is retained for compatibility
  but will be removed in a future release

If an expression is not provided for the content argument, the
nested expression will capture all whitespace-delimited content
between delimiters as a list of separate values.

Use the ``ignore_expr`` argument to define expressions that may
contain opening or closing characters that should not be treated as
opening or closing characters for nesting, such as quoted_string or
a comment expression.  Specify multiple expressions using an
:class:`Or` or :class:`MatchFirst`. The default is
:class:`quoted_string`, but if no expressions are to be ignored, then
pass ``None`` for this argument.

Example::

    data_type = one_of("void int short long char float double")
    decl_data_type = Combine(data_type + Opt(Word('*')))
    ident = Word(alphas+'_', alphanums+'_')
    number = pyparsing_common.number
    arg = Group(decl_data_type + ident)
    LPAR, RPAR = map(Suppress, "()")

    code_body = nested_expr('{', '}', ignore_expr=(quoted_string | c_style_comment))

    c_function = (decl_data_type("type")
                  + ident("name")
                  + LPAR + Opt(DelimitedList(arg), [])("args") + RPAR
                  + code_body("body"))
    c_function.ignore(c_style_comment)

    source_code = '''
        int is_odd(int x) {
            return (x%2);
        }

        int dec_to_hex(char hchar) {
            if (hchar &gt;= '0' &amp;&amp; hchar &lt;= '9') {
                return (ord(hchar)-ord('0'));
            } else {
                return (10+ord(hchar)-ord('A'));
            }
        }
    '''
    for func in c_function.search_string(source_code):
        print("%(name)s (%(type)s) args: %(args)s" % func)


prints::

    is_odd (int) args: [['int', 'x']]
    dec_to_hex (int) args: [['char', 'hchar']]
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00410">410</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  417</span>) -&gt; ParserElement:</div>
<div class="line"><span class="lineno">  418</span>    <span class="stringliteral">&quot;&quot;&quot;Helper method for defining nested lists enclosed in opening and</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    closing delimiters (``&quot;(&quot;`` and ``&quot;)&quot;`` are the default).</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    Parameters:</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    - ``opener`` - opening character for a nested list</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">      (default= ``&quot;(&quot;``); can also be a pyparsing expression</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    - ``closer`` - closing character for a nested list</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">      (default= ``&quot;)&quot;``); can also be a pyparsing expression</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    - ``content`` - expression for items within the nested lists</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">      (default= ``None``)</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    - ``ignore_expr`` - expression for ignoring opening and closing delimiters</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">      (default= :class:`quoted_string`)</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    - ``ignoreExpr`` - this pre-PEP8 argument is retained for compatibility</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">      but will be removed in a future release</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    If an expression is not provided for the content argument, the</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    nested expression will capture all whitespace-delimited content</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    between delimiters as a list of separate values.</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    Use the ``ignore_expr`` argument to define expressions that may</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    contain opening or closing characters that should not be treated as</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    opening or closing characters for nesting, such as quoted_string or</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral">    a comment expression.  Specify multiple expressions using an</span></div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    :class:`Or` or :class:`MatchFirst`. The default is</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    :class:`quoted_string`, but if no expressions are to be ignored, then</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    pass ``None`` for this argument.</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    Example::</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">        data_type = one_of(&quot;void int short long char float double&quot;)</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">        decl_data_type = Combine(data_type + Opt(Word(&#39;*&#39;)))</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">        ident = Word(alphas+&#39;_&#39;, alphanums+&#39;_&#39;)</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">        number = pyparsing_common.number</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">        arg = Group(decl_data_type + ident)</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">        LPAR, RPAR = map(Suppress, &quot;()&quot;)</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">        code_body = nested_expr(&#39;{&#39;, &#39;}&#39;, ignore_expr=(quoted_string | c_style_comment))</span></div>
<div class="line"><span class="lineno">  456</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  457</span><span class="stringliteral">        c_function = (decl_data_type(&quot;type&quot;)</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">                      + ident(&quot;name&quot;)</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral">                      + LPAR + Opt(DelimitedList(arg), [])(&quot;args&quot;) + RPAR</span></div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">                      + code_body(&quot;body&quot;))</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">        c_function.ignore(c_style_comment)</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">        source_code = &#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">            int is_odd(int x) {</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">                return (x%2);</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">            }</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral">            int dec_to_hex(char hchar) {</span></div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">                if (hchar &gt;= &#39;0&#39; &amp;&amp; hchar &lt;= &#39;9&#39;) {</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">                    return (ord(hchar)-ord(&#39;0&#39;));</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">                } else {</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">                    return (10+ord(hchar)-ord(&#39;A&#39;));</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">                }</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">            }</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">        &#39;&#39;&#39;</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">        for func in c_function.search_string(source_code):</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">            print(&quot;%(name)s (%(type)s) args: %(args)s&quot; % func)</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    prints::</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">        is_odd (int) args: [[&#39;int&#39;, &#39;x&#39;]]</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">        dec_to_hex (int) args: [[&#39;char&#39;, &#39;hchar&#39;]]</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  485</span>    <span class="keywordflow">if</span> ignoreExpr != ignore_expr:</div>
<div class="line"><span class="lineno">  486</span>        ignoreExpr = ignore_expr <span class="keywordflow">if</span> ignoreExpr == quoted_string() <span class="keywordflow">else</span> ignoreExpr</div>
<div class="line"><span class="lineno">  487</span>    <span class="keywordflow">if</span> opener == closer:</div>
<div class="line"><span class="lineno">  488</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;opening and closing strings cannot be the same&quot;</span>)</div>
<div class="line"><span class="lineno">  489</span>    <span class="keywordflow">if</span> content <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  490</span>        <span class="keywordflow">if</span> isinstance(opener, str_type) <span class="keywordflow">and</span> isinstance(closer, str_type):</div>
<div class="line"><span class="lineno">  491</span>            opener = typing.cast(str, opener)</div>
<div class="line"><span class="lineno">  492</span>            closer = typing.cast(str, closer)</div>
<div class="line"><span class="lineno">  493</span>            <span class="keywordflow">if</span> len(opener) == 1 <span class="keywordflow">and</span> len(closer) == 1:</div>
<div class="line"><span class="lineno">  494</span>                <span class="keywordflow">if</span> ignoreExpr <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  495</span>                    content = Combine(</div>
<div class="line"><span class="lineno">  496</span>                        OneOrMore(</div>
<div class="line"><span class="lineno">  497</span>                            ~ignoreExpr</div>
<div class="line"><span class="lineno">  498</span>                            + CharsNotIn(</div>
<div class="line"><span class="lineno">  499</span>                                opener + closer + ParserElement.DEFAULT_WHITE_CHARS,</div>
<div class="line"><span class="lineno">  500</span>                                exact=1,</div>
<div class="line"><span class="lineno">  501</span>                            )</div>
<div class="line"><span class="lineno">  502</span>                        )</div>
<div class="line"><span class="lineno">  503</span>                    ).set_parse_action(<span class="keyword">lambda</span> t: t[0].strip())</div>
<div class="line"><span class="lineno">  504</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  505</span>                    content = empty.copy() + CharsNotIn(</div>
<div class="line"><span class="lineno">  506</span>                        opener + closer + ParserElement.DEFAULT_WHITE_CHARS</div>
<div class="line"><span class="lineno">  507</span>                    ).set_parse_action(<span class="keyword">lambda</span> t: t[0].strip())</div>
<div class="line"><span class="lineno">  508</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  509</span>                <span class="keywordflow">if</span> ignoreExpr <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  510</span>                    content = Combine(</div>
<div class="line"><span class="lineno">  511</span>                        OneOrMore(</div>
<div class="line"><span class="lineno">  512</span>                            ~ignoreExpr</div>
<div class="line"><span class="lineno">  513</span>                            + ~Literal(opener)</div>
<div class="line"><span class="lineno">  514</span>                            + ~Literal(closer)</div>
<div class="line"><span class="lineno">  515</span>                            + CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS, exact=1)</div>
<div class="line"><span class="lineno">  516</span>                        )</div>
<div class="line"><span class="lineno">  517</span>                    ).set_parse_action(<span class="keyword">lambda</span> t: t[0].strip())</div>
<div class="line"><span class="lineno">  518</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  519</span>                    content = Combine(</div>
<div class="line"><span class="lineno">  520</span>                        OneOrMore(</div>
<div class="line"><span class="lineno">  521</span>                            ~Literal(opener)</div>
<div class="line"><span class="lineno">  522</span>                            + ~Literal(closer)</div>
<div class="line"><span class="lineno">  523</span>                            + CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS, exact=1)</div>
<div class="line"><span class="lineno">  524</span>                        )</div>
<div class="line"><span class="lineno">  525</span>                    ).set_parse_action(<span class="keyword">lambda</span> t: t[0].strip())</div>
<div class="line"><span class="lineno">  526</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  527</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  528</span>                <span class="stringliteral">&quot;opening and closing arguments must be strings if no content expression is given&quot;</span></div>
<div class="line"><span class="lineno">  529</span>            )</div>
<div class="line"><span class="lineno">  530</span>    ret = Forward()</div>
<div class="line"><span class="lineno">  531</span>    <span class="keywordflow">if</span> ignoreExpr <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  532</span>        ret &lt;&lt;= Group(</div>
<div class="line"><span class="lineno">  533</span>            Suppress(opener) + ZeroOrMore(ignoreExpr | ret | content) + Suppress(closer)</div>
<div class="line"><span class="lineno">  534</span>        )</div>
<div class="line"><span class="lineno">  535</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  536</span>        ret &lt;&lt;= Group(Suppress(opener) + ZeroOrMore(ret | content) + Suppress(closer))</div>
<div class="line"><span class="lineno">  537</span>    ret.set_name(<span class="stringliteral">&quot;nested %s%s expression&quot;</span> % (opener, closer))</div>
<div class="line"><span class="lineno">  538</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno">  539</span> </div>
<div class="line"><span class="lineno">  540</span> </div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../d5/dbf/pyparsing_2core_8py_source.html#l06057">pip._vendor.pyparsing.core.quoted_string</a>.</p>

</div>
</div>
<a id="ac124a4d7cc2c1bced7cb243fcd497bba" name="ac124a4d7cc2c1bced7cb243fcd497bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac124a4d7cc2c1bced7cb243fcd497bba">&#9670;&#160;</a></span>nestedExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nestedExpr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01087">1087</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1087</span><span class="keyword">def </span>nestedExpr(): ...</div>
<div class="line"><span class="lineno"> 1088</span> </div>
<div class="line"><span class="lineno"> 1089</span><span class="preprocessor">@replaced_by_pep8(make_html_tags)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1223bf0100ee5dd569d6829217ca647e" name="a1223bf0100ee5dd569d6829217ca647e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1223bf0100ee5dd569d6829217ca647e">&#9670;&#160;</a></span>one_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> one_of </td>
          <td>(</td>
          <td class="paramtype">Union[typing.Iterable[str], str]</td>          <td class="paramname"><span class="paramname"><em>strs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>caseless</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>use_regex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>as_keyword</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>useRegex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>asKeyword</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper to quickly define a set of alternative :class:`Literal` s,
and makes sure to do longest-first testing when there is a conflict,
regardless of the input order, but returns
a :class:`MatchFirst` for best performance.

Parameters:

- ``strs`` - a string of space-delimited literals, or a collection of
  string literals
- ``caseless`` - treat all literals as caseless - (default= ``False``)
- ``use_regex`` - as an optimization, will
  generate a :class:`Regex` object; otherwise, will generate
  a :class:`MatchFirst` object (if ``caseless=True`` or ``as_keyword=True``, or if
  creating a :class:`Regex` raises an exception) - (default= ``True``)
- ``as_keyword`` - enforce :class:`Keyword`-style matching on the
  generated expressions - (default= ``False``)
- ``asKeyword`` and ``useRegex`` are retained for pre-PEP8 compatibility,
  but will be removed in a future release

Example::

    comp_oper = one_of("&lt; = &gt; &lt;= &gt;= !=")
    var = Word(alphas)
    number = Word(nums)
    term = var | number
    comparison_expr = term + comp_oper + term
    print(comparison_expr.search_string("B = 12  AA=23 B&lt;=AA AA&gt;12"))

prints::

    [['B', '=', '12'], ['AA', '=', '23'], ['B', '&lt;=', 'AA'], ['AA', '&gt;', '12']]
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00149">149</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  157</span>) -&gt; ParserElement:</div>
<div class="line"><span class="lineno">  158</span>    <span class="stringliteral">&quot;&quot;&quot;Helper to quickly define a set of alternative :class:`Literal` s,</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    and makes sure to do longest-first testing when there is a conflict,</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    regardless of the input order, but returns</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">    a :class:`MatchFirst` for best performance.</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    Parameters:</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    - ``strs`` - a string of space-delimited literals, or a collection of</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">      string literals</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    - ``caseless`` - treat all literals as caseless - (default= ``False``)</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    - ``use_regex`` - as an optimization, will</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">      generate a :class:`Regex` object; otherwise, will generate</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">      a :class:`MatchFirst` object (if ``caseless=True`` or ``as_keyword=True``, or if</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">      creating a :class:`Regex` raises an exception) - (default= ``True``)</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    - ``as_keyword`` - enforce :class:`Keyword`-style matching on the</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">      generated expressions - (default= ``False``)</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    - ``asKeyword`` and ``useRegex`` are retained for pre-PEP8 compatibility,</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">      but will be removed in a future release</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    Example::</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">        comp_oper = one_of(&quot;&lt; = &gt; &lt;= &gt;= !=&quot;)</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">        var = Word(alphas)</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">        number = Word(nums)</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">        term = var | number</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">        comparison_expr = term + comp_oper + term</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">        print(comparison_expr.search_string(&quot;B = 12  AA=23 B&lt;=AA AA&gt;12&quot;))</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    prints::</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">        [[&#39;B&#39;, &#39;=&#39;, &#39;12&#39;], [&#39;AA&#39;, &#39;=&#39;, &#39;23&#39;], [&#39;B&#39;, &#39;&lt;=&#39;, &#39;AA&#39;], [&#39;AA&#39;, &#39;&gt;&#39;, &#39;12&#39;]]</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  190</span>    asKeyword = asKeyword <span class="keywordflow">or</span> as_keyword</div>
<div class="line"><span class="lineno">  191</span>    useRegex = useRegex <span class="keywordflow">and</span> use_regex</div>
<div class="line"><span class="lineno">  192</span> </div>
<div class="line"><span class="lineno">  193</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  194</span>        isinstance(caseless, str_type)</div>
<div class="line"><span class="lineno">  195</span>        <span class="keywordflow">and</span> __diag__.warn_on_multiple_string_args_to_oneof</div>
<div class="line"><span class="lineno">  196</span>    ):</div>
<div class="line"><span class="lineno">  197</span>        warnings.warn(</div>
<div class="line"><span class="lineno">  198</span>            <span class="stringliteral">&quot;More than one string argument passed to one_of, pass&quot;</span></div>
<div class="line"><span class="lineno">  199</span>            <span class="stringliteral">&quot; choices as a list or space-delimited string&quot;</span>,</div>
<div class="line"><span class="lineno">  200</span>            stacklevel=2,</div>
<div class="line"><span class="lineno">  201</span>        )</div>
<div class="line"><span class="lineno">  202</span> </div>
<div class="line"><span class="lineno">  203</span>    <span class="keywordflow">if</span> caseless:</div>
<div class="line"><span class="lineno">  204</span>        isequal = <span class="keyword">lambda</span> a, b: a.upper() == b.upper()</div>
<div class="line"><span class="lineno">  205</span>        masks = <span class="keyword">lambda</span> a, b: b.upper().startswith(a.upper())</div>
<div class="line"><span class="lineno">  206</span>        parseElementClass = CaselessKeyword <span class="keywordflow">if</span> asKeyword <span class="keywordflow">else</span> CaselessLiteral</div>
<div class="line"><span class="lineno">  207</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  208</span>        isequal = <span class="keyword">lambda</span> a, b: a == b</div>
<div class="line"><span class="lineno">  209</span>        masks = <span class="keyword">lambda</span> a, b: b.startswith(a)</div>
<div class="line"><span class="lineno">  210</span>        parseElementClass = Keyword <span class="keywordflow">if</span> asKeyword <span class="keywordflow">else</span> Literal</div>
<div class="line"><span class="lineno">  211</span> </div>
<div class="line"><span class="lineno">  212</span>    symbols: List[str] = []</div>
<div class="line"><span class="lineno">  213</span>    <span class="keywordflow">if</span> isinstance(strs, str_type):</div>
<div class="line"><span class="lineno">  214</span>        strs = typing.cast(str, strs)</div>
<div class="line"><span class="lineno">  215</span>        symbols = strs.split()</div>
<div class="line"><span class="lineno">  216</span>    <span class="keywordflow">elif</span> isinstance(strs, Iterable):</div>
<div class="line"><span class="lineno">  217</span>        symbols = list(strs)</div>
<div class="line"><span class="lineno">  218</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  219</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Invalid argument to one_of, expected string or iterable&quot;</span>)</div>
<div class="line"><span class="lineno">  220</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> symbols:</div>
<div class="line"><span class="lineno">  221</span>        <span class="keywordflow">return</span> NoMatch()</div>
<div class="line"><span class="lineno">  222</span> </div>
<div class="line"><span class="lineno">  223</span>    <span class="comment"># reorder given symbols to take care to avoid masking longer choices with shorter ones</span></div>
<div class="line"><span class="lineno">  224</span>    <span class="comment"># (but only if the given symbols are not just single characters)</span></div>
<div class="line"><span class="lineno">  225</span>    <span class="keywordflow">if</span> any(len(sym) &gt; 1 <span class="keywordflow">for</span> sym <span class="keywordflow">in</span> symbols):</div>
<div class="line"><span class="lineno">  226</span>        i = 0</div>
<div class="line"><span class="lineno">  227</span>        <span class="keywordflow">while</span> i &lt; len(symbols) - 1:</div>
<div class="line"><span class="lineno">  228</span>            cur = symbols[i]</div>
<div class="line"><span class="lineno">  229</span>            <span class="keywordflow">for</span> j, other <span class="keywordflow">in</span> enumerate(symbols[i + 1 :]):</div>
<div class="line"><span class="lineno">  230</span>                <span class="keywordflow">if</span> isequal(other, cur):</div>
<div class="line"><span class="lineno">  231</span>                    del symbols[i + j + 1]</div>
<div class="line"><span class="lineno">  232</span>                    <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  233</span>                <span class="keywordflow">elif</span> masks(cur, other):</div>
<div class="line"><span class="lineno">  234</span>                    del symbols[i + j + 1]</div>
<div class="line"><span class="lineno">  235</span>                    symbols.insert(i, other)</div>
<div class="line"><span class="lineno">  236</span>                    <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  237</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  238</span>                i += 1</div>
<div class="line"><span class="lineno">  239</span> </div>
<div class="line"><span class="lineno">  240</span>    <span class="keywordflow">if</span> useRegex:</div>
<div class="line"><span class="lineno">  241</span>        re_flags: int = re.IGNORECASE <span class="keywordflow">if</span> caseless <span class="keywordflow">else</span> 0</div>
<div class="line"><span class="lineno">  242</span> </div>
<div class="line"><span class="lineno">  243</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  244</span>            <span class="keywordflow">if</span> all(len(sym) == 1 <span class="keywordflow">for</span> sym <span class="keywordflow">in</span> symbols):</div>
<div class="line"><span class="lineno">  245</span>                <span class="comment"># symbols are just single characters, create range regex pattern</span></div>
<div class="line"><span class="lineno">  246</span>                patt = f<span class="stringliteral">&quot;[{&#39;&#39;.join(_escape_regex_range_chars(sym) for sym in symbols)}]&quot;</span></div>
<div class="line"><span class="lineno">  247</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  248</span>                patt = <span class="stringliteral">&quot;|&quot;</span>.join(re.escape(sym) <span class="keywordflow">for</span> sym <span class="keywordflow">in</span> symbols)</div>
<div class="line"><span class="lineno">  249</span> </div>
<div class="line"><span class="lineno">  250</span>            <span class="comment"># wrap with \b word break markers if defining as keywords</span></div>
<div class="line"><span class="lineno">  251</span>            <span class="keywordflow">if</span> asKeyword:</div>
<div class="line"><span class="lineno">  252</span>                patt = rf<span class="stringliteral">&quot;\b(?:{patt})\b&quot;</span></div>
<div class="line"><span class="lineno">  253</span> </div>
<div class="line"><span class="lineno">  254</span>            ret = Regex(patt, flags=re_flags).set_name(<span class="stringliteral">&quot; | &quot;</span>.join(symbols))</div>
<div class="line"><span class="lineno">  255</span> </div>
<div class="line"><span class="lineno">  256</span>            <span class="keywordflow">if</span> caseless:</div>
<div class="line"><span class="lineno">  257</span>                <span class="comment"># add parse action to return symbols as specified, not in random</span></div>
<div class="line"><span class="lineno">  258</span>                <span class="comment"># casing as found in input string</span></div>
<div class="line"><span class="lineno">  259</span>                symbol_map = {sym.lower(): sym <span class="keywordflow">for</span> sym <span class="keywordflow">in</span> symbols}</div>
<div class="line"><span class="lineno">  260</span>                ret.add_parse_action(<span class="keyword">lambda</span> s, l, t: symbol_map[t[0].lower()])</div>
<div class="line"><span class="lineno">  261</span> </div>
<div class="line"><span class="lineno">  262</span>            <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno">  263</span> </div>
<div class="line"><span class="lineno">  264</span>        <span class="keywordflow">except</span> re.error:</div>
<div class="line"><span class="lineno">  265</span>            warnings.warn(</div>
<div class="line"><span class="lineno">  266</span>                <span class="stringliteral">&quot;Exception creating Regex for one_of, building MatchFirst&quot;</span>, stacklevel=2</div>
<div class="line"><span class="lineno">  267</span>            )</div>
<div class="line"><span class="lineno">  268</span> </div>
<div class="line"><span class="lineno">  269</span>    <span class="comment"># last resort, just use MatchFirst</span></div>
<div class="line"><span class="lineno">  270</span>    <span class="keywordflow">return</span> MatchFirst(parseElementClass(sym) <span class="keywordflow">for</span> sym <span class="keywordflow">in</span> symbols).set_name(</div>
<div class="line"><span class="lineno">  271</span>        <span class="stringliteral">&quot; | &quot;</span>.join(symbols)</div>
<div class="line"><span class="lineno">  272</span>    )</div>
<div class="line"><span class="lineno">  273</span> </div>
<div class="line"><span class="lineno">  274</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a364c6ad71d25ff9e9d5b4cca26b7c064" name="a364c6ad71d25ff9e9d5b4cca26b7c064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364c6ad71d25ff9e9d5b4cca26b7c064">&#9670;&#160;</a></span>oneOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">oneOf </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01078">1078</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1078</span><span class="keyword">def </span>oneOf(): ...</div>
<div class="line"><span class="lineno"> 1079</span> </div>
<div class="line"><span class="lineno"> 1080</span><span class="preprocessor">@replaced_by_pep8(dict_of)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a393a0bb189c88de859edc6306176ccc4" name="a393a0bb189c88de859edc6306176ccc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393a0bb189c88de859edc6306176ccc4">&#9670;&#160;</a></span>original_text_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> original_text_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>as_string</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>          <td class="paramname"><span class="paramname"><em>asString</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper to return the original, untokenized text for a given
expression.  Useful to restore the parsed fields of an HTML start
tag into the raw tag text itself, or to revert separate tokens with
intervening whitespace back to the original matching input text. By
default, returns a string containing the original parsed text.

If the optional ``as_string`` argument is passed as
``False``, then the return value is
a :class:`ParseResults` containing any results names that
were originally matched, and a single token containing the original
matched text from the input string.  So if the expression passed to
:class:`original_text_for` contains expressions with defined
results names, you must set ``as_string`` to ``False`` if you
want to preserve those results name values.

The ``asString`` pre-PEP8 argument is retained for compatibility,
but will be removed in a future release.

Example::

    src = "this is test &lt;b&gt; bold &lt;i&gt;text&lt;/i&gt; &lt;/b&gt; normal text "
    for tag in ("b", "i"):
        opener, closer = make_html_tags(tag)
        patt = original_text_for(opener + ... + closer)
        print(patt.search_string(src)[0])

prints::

    ['&lt;b&gt; bold &lt;i&gt;text&lt;/i&gt; &lt;/b&gt;']
    ['&lt;i&gt;text&lt;/i&gt;']
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00315">315</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  317</span>) -&gt; ParserElement:</div>
<div class="line"><span class="lineno">  318</span>    <span class="stringliteral">&quot;&quot;&quot;Helper to return the original, untokenized text for a given</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    expression.  Useful to restore the parsed fields of an HTML start</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    tag into the raw tag text itself, or to revert separate tokens with</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    intervening whitespace back to the original matching input text. By</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    default, returns a string containing the original parsed text.</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    If the optional ``as_string`` argument is passed as</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    ``False``, then the return value is</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    a :class:`ParseResults` containing any results names that</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    were originally matched, and a single token containing the original</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    matched text from the input string.  So if the expression passed to</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    :class:`original_text_for` contains expressions with defined</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    results names, you must set ``as_string`` to ``False`` if you</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    want to preserve those results name values.</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    The ``asString`` pre-PEP8 argument is retained for compatibility,</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    but will be removed in a future release.</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    Example::</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">        src = &quot;this is test &lt;b&gt; bold &lt;i&gt;text&lt;/i&gt; &lt;/b&gt; normal text &quot;</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">        for tag in (&quot;b&quot;, &quot;i&quot;):</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">            opener, closer = make_html_tags(tag)</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">            patt = original_text_for(opener + ... + closer)</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">            print(patt.search_string(src)[0])</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    prints::</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">        [&#39;&lt;b&gt; bold &lt;i&gt;text&lt;/i&gt; &lt;/b&gt;&#39;]</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">        [&#39;&lt;i&gt;text&lt;/i&gt;&#39;]</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  349</span>    asString = asString <span class="keywordflow">and</span> as_string</div>
<div class="line"><span class="lineno">  350</span> </div>
<div class="line"><span class="lineno">  351</span>    locMarker = Empty().set_parse_action(<span class="keyword">lambda</span> s, loc, t: loc)</div>
<div class="line"><span class="lineno">  352</span>    endlocMarker = locMarker.copy()</div>
<div class="line"><span class="lineno">  353</span>    endlocMarker.callPreparse = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  354</span>    matchExpr = locMarker(<span class="stringliteral">&quot;_original_start&quot;</span>) + expr + endlocMarker(<span class="stringliteral">&quot;_original_end&quot;</span>)</div>
<div class="line"><span class="lineno">  355</span>    <span class="keywordflow">if</span> asString:</div>
<div class="line"><span class="lineno">  356</span>        extractText = <span class="keyword">lambda</span> s, l, t: s[t._original_start : t._original_end]</div>
<div class="line"><span class="lineno">  357</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  358</span> </div>
<div class="line"><span class="lineno">  359</span>        <span class="keyword">def </span>extractText(s, l, t):</div>
<div class="line"><span class="lineno">  360</span>            t[:] = [s[t.pop(<span class="stringliteral">&quot;_original_start&quot;</span>) : t.pop(<span class="stringliteral">&quot;_original_end&quot;</span>)]]</div>
<div class="line"><span class="lineno">  361</span> </div>
<div class="line"><span class="lineno">  362</span>    matchExpr.set_parse_action(extractText)</div>
<div class="line"><span class="lineno">  363</span>    matchExpr.ignoreExprs = expr.ignoreExprs</div>
<div class="line"><span class="lineno">  364</span>    matchExpr.suppress_warning(Diagnostics.warn_ungrouped_named_tokens_in_collection)</div>
<div class="line"><span class="lineno">  365</span>    <span class="keywordflow">return</span> matchExpr</div>
<div class="line"><span class="lineno">  366</span> </div>
<div class="line"><span class="lineno">  367</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a77d06d3576a870e167580e90b7cc21" name="a1a77d06d3576a870e167580e90b7cc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a77d06d3576a870e167580e90b7cc21">&#9670;&#160;</a></span>originalTextFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">originalTextFor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01084">1084</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1084</span><span class="keyword">def </span>originalTextFor(): ...</div>
<div class="line"><span class="lineno"> 1085</span> </div>
<div class="line"><span class="lineno"> 1086</span><span class="preprocessor">@replaced_by_pep8(nested_expr)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a57d892d89e8867238db64e7b794cee6e" name="a57d892d89e8867238db64e7b794cee6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d892d89e8867238db64e7b794cee6e">&#9670;&#160;</a></span>replace_html_entity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">replace_html_entity </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>l</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper parser action to replace common HTML entities with their special characters</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00649">649</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  649</span><span class="keyword">def </span>replace_html_entity(s, l, t):</div>
<div class="line"><span class="lineno">  650</span>    <span class="stringliteral">&quot;&quot;&quot;Helper parser action to replace common HTML entities with their special characters&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  651</span>    <span class="keywordflow">return</span> _htmlEntityMap.get(t.entity)</div>
<div class="line"><span class="lineno">  652</span> </div>
<div class="line"><span class="lineno">  653</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8d650f775915b22fbf96f14121382d41" name="a8d650f775915b22fbf96f14121382d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d650f775915b22fbf96f14121382d41">&#9670;&#160;</a></span>replaceHTMLEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">replaceHTMLEntity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01096">1096</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1096</span><span class="keyword">def </span>replaceHTMLEntity(): ...</div>
<div class="line"><span class="lineno"> 1097</span> </div>
<div class="line"><span class="lineno"> 1098</span><span class="preprocessor">@replaced_by_pep8(infix_notation)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5af53f3b8905da730a89a54b5167deab" name="a5af53f3b8905da730a89a54b5167deab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af53f3b8905da730a89a54b5167deab">&#9670;&#160;</a></span>ungroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> ungroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper to undo pyparsing's default grouping of And expressions,
even if all but one are non-empty.
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00368">368</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  368</span><span class="keyword">def </span>ungroup(expr: ParserElement) -&gt; ParserElement:</div>
<div class="line"><span class="lineno">  369</span>    <span class="stringliteral">&quot;&quot;&quot;Helper to undo pyparsing&#39;s default grouping of And expressions,</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    even if all but one are non-empty.</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  372</span>    <span class="keywordflow">return</span> TokenConverter(expr).add_parse_action(<span class="keyword">lambda</span> t: t[0])</div>
<div class="line"><span class="lineno">  373</span> </div>
<div class="line"><span class="lineno">  374</span> </div>
</div><!-- fragment -->
</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="ae3ac06a44de11c72db8d322c8499b63c" name="ae3ac06a44de11c72db8d322c8499b63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ac06a44de11c72db8d322c8499b63c">&#9670;&#160;</a></span>_builtin_exprs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list _builtin_exprs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  [</div>
<div class="line"><span class="lineno">    2</span>    v <span class="keywordflow">for</span> v <span class="keywordflow">in</span> vars().values() <span class="keywordflow">if</span> isinstance(v, ParserElement)</div>
<div class="line"><span class="lineno">    3</span>]</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01027">1027</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a047e5e223aae7489e33f5b80f41ec116" name="a047e5e223aae7489e33f5b80f41ec116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047e5e223aae7489e33f5b80f41ec116">&#9670;&#160;</a></span>_htmlEntityMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict _htmlEntityMap = {k.rstrip(&quot;;&quot;): v <a class="el" href="../../d2/d00/prime__search_8m.html#ace560ef83cc4488bf05ef19ddc3f6f34">for</a> k, v in html.entities.html5.items()}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00643">643</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="ad9bb74e07c8d28a27d406e8d6b854e38" name="ad9bb74e07c8d28a27d406e8d6b854e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bb74e07c8d28a27d406e8d6b854e38">&#9670;&#160;</a></span>any_close_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">any_close_tag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00639">639</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a2c796b6b07970245107bcd7e2c804eff" name="a2c796b6b07970245107bcd7e2c804eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c796b6b07970245107bcd7e2c804eff">&#9670;&#160;</a></span>any_open_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> any_open_tag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00639">639</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a91098f82290f3d945c5e61fcc3ef0643" name="a91098f82290f3d945c5e61fcc3ef0643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91098f82290f3d945c5e61fcc3ef0643">&#9670;&#160;</a></span>anyCloseTag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anyCloseTag = <a class="el" href="#ad9bb74e07c8d28a27d406e8d6b854e38">any_close_tag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01052">1052</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a89443f23bd7f10a1dd3ec7a30fbc1f90" name="a89443f23bd7f10a1dd3ec7a30fbc1f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89443f23bd7f10a1dd3ec7a30fbc1f90">&#9670;&#160;</a></span>anyOpenTag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/df1/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_parser_element.html">ParserElement</a> anyOpenTag = <a class="el" href="#a2c796b6b07970245107bcd7e2c804eff">any_open_tag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01051">1051</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a94f77d2e92e4932420592c1d562734d0" name="a94f77d2e92e4932420592c1d562734d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f77d2e92e4932420592c1d562734d0">&#9670;&#160;</a></span>c_style_comment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">c_style_comment</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  Combine(Regex(<span class="stringliteral">r&quot;/\*(?:[^*]|\*(?!/))*&quot;</span>) + <span class="stringliteral">&quot;*/&quot;</span>).set_name(</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;C style comment&quot;</span></div>
<div class="line"><span class="lineno">    3</span>)</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01001">1001</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a092f994e0bc691fed7ec122ee421a5bf" name="a092f994e0bc691fed7ec122ee421a5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092f994e0bc691fed7ec122ee421a5bf">&#9670;&#160;</a></span>common_html_entity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">common_html_entity</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  Regex(<span class="stringliteral">&quot;&amp;(?P&lt;entity&gt;&quot;</span> + <span class="stringliteral">&quot;|&quot;</span>.join(_htmlEntityMap) + <span class="stringliteral">&quot;);&quot;</span>).set_name(</div>
<div class="line"><span class="lineno">    2</span>    <span class="stringliteral">&quot;common HTML entity&quot;</span></div>
<div class="line"><span class="lineno">    3</span>)</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00644">644</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a7f80f97b0a7e5a08496b213c71d76301" name="a7f80f97b0a7e5a08496b213c71d76301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f80f97b0a7e5a08496b213c71d76301">&#9670;&#160;</a></span>commonHTMLEntity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">commonHTMLEntity = <a class="el" href="#a092f994e0bc691fed7ec122ee421a5bf">common_html_entity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01053">1053</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="aba5207462b24d6364ba9ef3472c12247" name="aba5207462b24d6364ba9ef3472c12247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5207462b24d6364ba9ef3472c12247">&#9670;&#160;</a></span>cpp_style_comment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cpp_style_comment</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  Combine(</div>
<div class="line"><span class="lineno">    2</span>    Regex(<span class="stringliteral">r&quot;/\*(?:[^*]|\*(?!/))*&quot;</span>) + <span class="stringliteral">&quot;*/&quot;</span> | dbl_slash_comment</div>
<div class="line"><span class="lineno">    3</span>).set_name(<span class="stringliteral">&quot;C++ style comment&quot;</span>)</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01013">1013</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a8e7682f0a25965d2916d2cceadc749e9" name="a8e7682f0a25965d2916d2cceadc749e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7682f0a25965d2916d2cceadc749e9">&#9670;&#160;</a></span>cppStyleComment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cppStyleComment = <a class="el" href="#aba5207462b24d6364ba9ef3472c12247">cpp_style_comment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01058">1058</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a895af36e449c2367f530adbdc5d935e2" name="a895af36e449c2367f530adbdc5d935e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895af36e449c2367f530adbdc5d935e2">&#9670;&#160;</a></span>cStyleComment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cStyleComment = <a class="el" href="#a94f77d2e92e4932420592c1d562734d0">c_style_comment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01054">1054</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a222d83ba5a187d473bfb260fe8a76141" name="a222d83ba5a187d473bfb260fe8a76141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222d83ba5a187d473bfb260fe8a76141">&#9670;&#160;</a></span>dbl_slash_comment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dbl_slash_comment = <a class="el" href="../../d2/d3c/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_regex.html">Regex</a>(r&quot;//(?:\\\n|[^\n])*&quot;).set_name(&quot;// comment&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01010">1010</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a4b0fb4b75d2a7eac67175e156af9f9fd" name="a4b0fb4b75d2a7eac67175e156af9f9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0fb4b75d2a7eac67175e156af9f9fd">&#9670;&#160;</a></span>dblSlashComment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dblSlashComment = <a class="el" href="#a222d83ba5a187d473bfb260fe8a76141">dbl_slash_comment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01057">1057</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="aa51b7b384ad578c0391f372c76c3b1fe" name="aa51b7b384ad578c0391f372c76c3b1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51b7b384ad578c0391f372c76c3b1fe">&#9670;&#160;</a></span>html_comment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">html_comment = <a class="el" href="../../d2/d3c/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_regex.html">Regex</a>(r&quot;&lt;!--[\s\S]*?--&gt;&quot;).set_name(&quot;HTML comment&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01006">1006</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="aabee8ef3c357ba56650e39fb3ab14bbe" name="aabee8ef3c357ba56650e39fb3ab14bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabee8ef3c357ba56650e39fb3ab14bbe">&#9670;&#160;</a></span>htmlComment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">htmlComment = <a class="el" href="#aa51b7b384ad578c0391f372c76c3b1fe">html_comment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01055">1055</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="aee3d4b5ec7657944e5809e120e0349ba" name="aee3d4b5ec7657944e5809e120e0349ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3d4b5ec7657944e5809e120e0349ba">&#9670;&#160;</a></span>InfixNotationOperatorArgType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InfixNotationOperatorArgType</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  Union[</div>
<div class="line"><span class="lineno">    2</span>    ParserElement, str, Tuple[Union[ParserElement, str], Union[ParserElement, str]]</div>
<div class="line"><span class="lineno">    3</span>]</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00662">662</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a732829e9bcf9affdfe67f35af42c0915" name="a732829e9bcf9affdfe67f35af42c0915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732829e9bcf9affdfe67f35af42c0915">&#9670;&#160;</a></span>InfixNotationOperatorSpec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InfixNotationOperatorSpec</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  Union[</div>
<div class="line"><span class="lineno">    2</span>    Tuple[</div>
<div class="line"><span class="lineno">    3</span>        InfixNotationOperatorArgType,</div>
<div class="line"><span class="lineno">    4</span>        int,</div>
<div class="line"><span class="lineno">    5</span>        OpAssoc,</div>
<div class="line"><span class="lineno">    6</span>        typing.Optional[ParseAction],</div>
<div class="line"><span class="lineno">    7</span>    ],</div>
<div class="line"><span class="lineno">    8</span>    Tuple[</div>
<div class="line"><span class="lineno">    9</span>        InfixNotationOperatorArgType,</div>
<div class="line"><span class="lineno">   10</span>        int,</div>
<div class="line"><span class="lineno">   11</span>        OpAssoc,</div>
<div class="line"><span class="lineno">   12</span>    ],</div>
<div class="line"><span class="lineno">   13</span>]</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l00665">665</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="aa6be426385d10903cb8f653a282d5a07" name="aa6be426385d10903cb8f653a282d5a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6be426385d10903cb8f653a282d5a07">&#9670;&#160;</a></span>java_style_comment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">java_style_comment = <a class="el" href="#aba5207462b24d6364ba9ef3472c12247">cpp_style_comment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01018">1018</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a95a4a4592db29ee9a5cb46c07d86e715" name="a95a4a4592db29ee9a5cb46c07d86e715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a4a4592db29ee9a5cb46c07d86e715">&#9670;&#160;</a></span>javaStyleComment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">javaStyleComment = <a class="el" href="#aa6be426385d10903cb8f653a282d5a07">java_style_comment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01059">1059</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="acfe54ba9c774a0b721484b122675ae49" name="acfe54ba9c774a0b721484b122675ae49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe54ba9c774a0b721484b122675ae49">&#9670;&#160;</a></span>opAssoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">opAssoc = <a class="el" href="../../d9/db3/classpip_1_1__vendor_1_1pyparsing_1_1helpers_1_1_op_assoc.html">OpAssoc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01050">1050</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a1bd3a91984dd47292168fbdfb7302dc0" name="a1bd3a91984dd47292168fbdfb7302dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd3a91984dd47292168fbdfb7302dc0">&#9670;&#160;</a></span>python_style_comment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">python_style_comment = <a class="el" href="../../d2/d3c/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_regex.html">Regex</a>(r&quot;#.*&quot;).set_name(&quot;Python style comment&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01021">1021</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a43485b104d2aeb59f207edd35054d3dd" name="a43485b104d2aeb59f207edd35054d3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43485b104d2aeb59f207edd35054d3dd">&#9670;&#160;</a></span>pythonStyleComment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pythonStyleComment = <a class="el" href="#a1bd3a91984dd47292168fbdfb7302dc0">python_style_comment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01060">1060</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="a3fa0a48a3ccef1245bd6748bc8a34fc6" name="a3fa0a48a3ccef1245bd6748bc8a34fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa0a48a3ccef1245bd6748bc8a34fc6">&#9670;&#160;</a></span>rest_of_line</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rest_of_line = <a class="el" href="../../d2/d3c/classpip_1_1__vendor_1_1pyparsing_1_1core_1_1_regex.html">Regex</a>(r&quot;.*&quot;).leave_whitespace().set_name(&quot;rest of line&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01009">1009</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
<a id="ac9d295aa38fd39ae00f04140cc6531bc" name="ac9d295aa38fd39ae00f04140cc6531bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d295aa38fd39ae00f04140cc6531bc">&#9670;&#160;</a></span>restOfLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">restOfLine = <a class="el" href="#a3fa0a48a3ccef1245bd6748bc8a34fc6">rest_of_line</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/deb/helpers_8py_source.html#l01056">1056</a> of file <a class="el" href="../../d2/deb/helpers_8py_source.html">helpers.py</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="../../d4/d6e/namespacepip.html">pip</a></li><li class="navelem"><a href="../../d8/d63/namespacepip_1_1__vendor.html">_vendor</a></li><li class="navelem"><a href="../../da/db0/namespacepip_1_1__vendor_1_1pyparsing.html">pyparsing</a></li><li class="navelem"><a href="../../d8/d65/namespacepip_1_1__vendor_1_1pyparsing_1_1helpers.html">helpers</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
